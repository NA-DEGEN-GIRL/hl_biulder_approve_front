const Mt=BigInt(0),_t=BigInt(1);function wt(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function jt(t){if(!wt(t))throw new Error("Uint8Array expected")}function dt(t,n){if(typeof n!="boolean")throw new Error(t+" boolean expected, got "+n)}function yt(t){const n=t.toString(16);return n.length&1?"0"+n:n}function ne(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?Mt:BigInt("0x"+t)}const re=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Ee=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function ht(t){if(jt(t),re)return t.toHex();let n="";for(let e=0;e<t.length;e++)n+=Ee[t[e]];return n}const W={_0:48,_9:57,A:65,F:70,a:97,f:102};function Gt(t){if(t>=W._0&&t<=W._9)return t-W._0;if(t>=W.A&&t<=W.F)return t-(W.A-10);if(t>=W.a&&t<=W.f)return t-(W.a-10)}function bt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);if(re)return Uint8Array.fromHex(t);const n=t.length,e=n/2;if(n%2)throw new Error("hex string expected, got unpadded hex of length "+n);const r=new Uint8Array(e);for(let i=0,s=0;i<e;i++,s+=2){const c=Gt(t.charCodeAt(s)),f=Gt(t.charCodeAt(s+1));if(c===void 0||f===void 0){const o=t[s]+t[s+1];throw new Error('hex string expected, got non-hex character "'+o+'" at index '+s)}r[i]=c*16+f}return r}function ot(t){return ne(ht(t))}function oe(t){return jt(t),ne(ht(Uint8Array.from(t).reverse()))}function gt(t,n){return bt(t.toString(16).padStart(n*2,"0"))}function ie(t,n){return gt(t,n).reverse()}function K(t,n,e){let r;if(typeof n=="string")try{r=bt(n)}catch(s){throw new Error(t+" must be hex string or Uint8Array, cause: "+s)}else if(wt(n))r=Uint8Array.from(n);else throw new Error(t+" must be hex string or Uint8Array");const i=r.length;if(typeof e=="number"&&i!==e)throw new Error(t+" of length "+e+" expected, got "+i);return r}function mt(...t){let n=0;for(let r=0;r<t.length;r++){const i=t[r];jt(i),n+=i.length}const e=new Uint8Array(n);for(let r=0,i=0;r<t.length;r++){const s=t[r];e.set(s,i),i+=s.length}return e}const It=t=>typeof t=="bigint"&&Mt<=t;function Yt(t,n,e){return It(t)&&It(n)&&It(e)&&n<=t&&t<e}function at(t,n,e,r){if(!Yt(n,e,r))throw new Error("expected valid "+t+": "+e+" <= n < "+r+", got "+n)}function Be(t){let n;for(n=0;t>Mt;t>>=_t,n+=1);return n}const Bt=t=>(_t<<BigInt(t))-_t,Nt=t=>new Uint8Array(t),$t=t=>Uint8Array.from(t);function ve(t,n,e){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=Nt(t),i=Nt(t),s=0;const c=()=>{r.fill(1),i.fill(0),s=0},f=(...h)=>e(i,r,...h),o=(h=Nt(0))=>{i=f($t([0]),h),r=f(),h.length!==0&&(i=f($t([1]),h),r=f())},l=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let h=0;const B=[];for(;h<n;){r=f();const H=r.slice();B.push(H),h+=r.length}return mt(...B)};return(h,B)=>{c(),o(h);let H;for(;!(H=B(l()));)o();return c(),H}}const Ae={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||wt(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function vt(t,n,e={}){const r=(i,s,c)=>{const f=Ae[s];if(typeof f!="function")throw new Error("invalid validator function");const o=t[i];if(!(c&&o===void 0)&&!f(o,t))throw new Error("param "+String(i)+" is invalid. Expected "+s+", got "+o)};for(const[i,s]of Object.entries(n))r(i,s,!1);for(const[i,s]of Object.entries(e))r(i,s,!0);return t}function Wt(t){const n=new WeakMap;return(e,...r)=>{const i=n.get(e);if(i!==void 0)return i;const s=t(e,...r);return n.set(e,s),s}}const ft=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;function Se(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function kt(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function pt(t,...n){if(!Se(t))throw new Error("Uint8Array expected");if(n.length>0&&!n.includes(t.length))throw new Error("Uint8Array expected of length "+n+", got length="+t.length)}function Ie(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");kt(t.outputLen),kt(t.blockLen)}function xt(t,n=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(n&&t.finished)throw new Error("Hash#digest() has already been called")}function Ne(t,n){pt(t);const e=n.outputLen;if(t.length<e)throw new Error("digestInto() expects output buffer of length at least "+e)}function Et(...t){for(let n=0;n<t.length;n++)t[n].fill(0)}function Ot(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function G(t,n){return t<<32-n|t>>>n}function Oe(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}function Kt(t){return typeof t=="string"&&(t=Oe(t)),pt(t),t}function He(...t){let n=0;for(let r=0;r<t.length;r++){const i=t[r];pt(i),n+=i.length}const e=new Uint8Array(n);for(let r=0,i=0;r<t.length;r++){const s=t[r];e.set(s,i),i+=s.length}return e}class se{}function qe(t){const n=r=>t().update(Kt(r)).digest(),e=t();return n.outputLen=e.outputLen,n.blockLen=e.blockLen,n.create=()=>t(),n}function Le(t=32){if(ft&&typeof ft.getRandomValues=="function")return ft.getRandomValues(new Uint8Array(t));if(ft&&typeof ft.randomBytes=="function")return Uint8Array.from(ft.randomBytes(t));throw new Error("crypto.getRandomValues must be defined")}function Ue(t,n,e,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(n,e,r);const i=BigInt(32),s=BigInt(4294967295),c=Number(e>>i&s),f=Number(e&s),o=r?4:0,l=r?0:4;t.setUint32(n+o,c,r),t.setUint32(n+l,f,r)}function Re(t,n,e){return t&n^~t&e}function Te(t,n,e){return t&n^t&e^n&e}class _e extends se{constructor(n,e,r,i){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=n,this.outputLen=e,this.padOffset=r,this.isLE=i,this.buffer=new Uint8Array(n),this.view=Ot(this.buffer)}update(n){xt(this),n=Kt(n),pt(n);const{view:e,buffer:r,blockLen:i}=this,s=n.length;for(let c=0;c<s;){const f=Math.min(i-this.pos,s-c);if(f===i){const o=Ot(n);for(;i<=s-c;c+=i)this.process(o,c);continue}r.set(n.subarray(c,c+f),this.pos),this.pos+=f,c+=f,this.pos===i&&(this.process(e,0),this.pos=0)}return this.length+=n.length,this.roundClean(),this}digestInto(n){xt(this),Ne(n,this),this.finished=!0;const{buffer:e,view:r,blockLen:i,isLE:s}=this;let{pos:c}=this;e[c++]=128,Et(this.buffer.subarray(c)),this.padOffset>i-c&&(this.process(r,0),c=0);for(let h=c;h<i;h++)e[h]=0;Ue(r,i-8,BigInt(this.length*8),s),this.process(r,0);const f=Ot(n),o=this.outputLen;if(o%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const l=o/4,g=this.get();if(l>g.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<l;h++)f.setUint32(4*h,g[h],s)}digest(){const{buffer:n,outputLen:e}=this;this.digestInto(n);const r=n.slice(0,e);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());const{blockLen:e,buffer:r,length:i,finished:s,destroyed:c,pos:f}=this;return n.destroyed=c,n.finished=s,n.length=i,n.pos=f,i%e&&n.buffer.set(r),n}clone(){return this._cloneInto()}}const J=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ke=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),tt=new Uint32Array(64);class Ze extends _e{constructor(n=32){super(64,n,8,!1),this.A=J[0]|0,this.B=J[1]|0,this.C=J[2]|0,this.D=J[3]|0,this.E=J[4]|0,this.F=J[5]|0,this.G=J[6]|0,this.H=J[7]|0}get(){const{A:n,B:e,C:r,D:i,E:s,F:c,G:f,H:o}=this;return[n,e,r,i,s,c,f,o]}set(n,e,r,i,s,c,f,o){this.A=n|0,this.B=e|0,this.C=r|0,this.D=i|0,this.E=s|0,this.F=c|0,this.G=f|0,this.H=o|0}process(n,e){for(let h=0;h<16;h++,e+=4)tt[h]=n.getUint32(e,!1);for(let h=16;h<64;h++){const B=tt[h-15],H=tt[h-2],R=G(B,7)^G(B,18)^B>>>3,p=G(H,17)^G(H,19)^H>>>10;tt[h]=p+tt[h-7]+R+tt[h-16]|0}let{A:r,B:i,C:s,D:c,E:f,F:o,G:l,H:g}=this;for(let h=0;h<64;h++){const B=G(f,6)^G(f,11)^G(f,25),H=g+B+Re(f,o,l)+ke[h]+tt[h]|0,p=(G(r,2)^G(r,13)^G(r,22))+Te(r,i,s)|0;g=l,l=o,o=f,f=c+H|0,c=s,s=i,i=r,r=H+p|0}r=r+this.A|0,i=i+this.B|0,s=s+this.C|0,c=c+this.D|0,f=f+this.E|0,o=o+this.F|0,l=l+this.G|0,g=g+this.H|0,this.set(r,i,s,c,f,o,l,g)}roundClean(){Et(tt)}destroy(){this.set(0,0,0,0,0,0,0,0),Et(this.buffer)}}const ze=qe(()=>new Ze);class ce extends se{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,Ie(n);const r=Kt(e);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const i=this.blockLen,s=new Uint8Array(i);s.set(r.length>i?n.create().update(r).digest():r);for(let c=0;c<s.length;c++)s[c]^=54;this.iHash.update(s),this.oHash=n.create();for(let c=0;c<s.length;c++)s[c]^=106;this.oHash.update(s),Et(s)}update(n){return xt(this),this.iHash.update(n),this}digestInto(n){xt(this),pt(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:i,destroyed:s,blockLen:c,outputLen:f}=this;return n=n,n.finished=i,n.destroyed=s,n.blockLen=c,n.outputLen=f,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const fe=(t,n,e)=>new ce(t,n).update(e).digest();fe.create=(t,n)=>new ce(t,n);const j=BigInt(0),C=BigInt(1),rt=BigInt(2),Ce=BigInt(3),ae=BigInt(4),ue=BigInt(5),le=BigInt(8);function M(t,n){const e=t%n;return e>=j?e:n+e}function Y(t,n,e){let r=t;for(;n-- >j;)r*=r,r%=e;return r}function Zt(t,n){if(t===j)throw new Error("invert: expected non-zero number");if(n<=j)throw new Error("invert: expected positive modulus, got "+n);let e=M(t,n),r=n,i=j,s=C;for(;e!==j;){const f=r/e,o=r%e,l=i-s*f;r=e,e=o,i=s,s=l}if(r!==C)throw new Error("invert: does not exist");return M(i,n)}function de(t,n){const e=(t.ORDER+C)/ae,r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}function Ve(t,n){const e=(t.ORDER-ue)/le,r=t.mul(n,rt),i=t.pow(r,e),s=t.mul(n,i),c=t.mul(t.mul(s,rt),i),f=t.mul(s,t.sub(c,t.ONE));if(!t.eql(t.sqr(f),n))throw new Error("Cannot find square root");return f}function Me(t){if(t<BigInt(3))throw new Error("sqrt is not defined for small field");let n=t-C,e=0;for(;n%rt===j;)n/=rt,e++;let r=rt;const i=Pt(t);for(;Ft(i,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(e===1)return de;let s=i.pow(r,n);const c=(n+C)/rt;return function(o,l){if(o.is0(l))return l;if(Ft(o,l)!==1)throw new Error("Cannot find square root");let g=e,h=o.mul(o.ONE,s),B=o.pow(l,n),H=o.pow(l,c);for(;!o.eql(B,o.ONE);){if(o.is0(B))return o.ZERO;let R=1,p=o.sqr(B);for(;!o.eql(p,o.ONE);)if(R++,p=o.sqr(p),R===g)throw new Error("Cannot find square root");const Z=C<<BigInt(g-R-1),T=o.pow(h,Z);g=R,h=o.sqr(T),B=o.mul(B,h),H=o.mul(H,T)}return H}}function je(t){return t%ae===Ce?de:t%le===ue?Ve:Me(t)}const Ye=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ke(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=Ye.reduce((r,i)=>(r[i]="function",r),n);return vt(t,e)}function Pe(t,n,e){if(e<j)throw new Error("invalid exponent, negatives unsupported");if(e===j)return t.ONE;if(e===C)return n;let r=t.ONE,i=n;for(;e>j;)e&C&&(r=t.mul(r,i)),i=t.sqr(i),e>>=C;return r}function he(t,n,e=!1){const r=new Array(n.length).fill(e?t.ZERO:void 0),i=n.reduce((c,f,o)=>t.is0(f)?c:(r[o]=c,t.mul(c,f)),t.ONE),s=t.inv(i);return n.reduceRight((c,f,o)=>t.is0(f)?c:(r[o]=t.mul(c,r[o]),t.mul(c,f)),s),r}function Ft(t,n){const e=(t.ORDER-C)/rt,r=t.pow(n,e),i=t.eql(r,t.ONE),s=t.eql(r,t.ZERO),c=t.eql(r,t.neg(t.ONE));if(!i&&!s&&!c)throw new Error("invalid Legendre symbol result");return i?1:s?0:-1}function we(t,n){n!==void 0&&kt(n);const e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function Pt(t,n,e=!1,r={}){if(t<=j)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:i,nByteLength:s}=we(t,n);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c;const f=Object.freeze({ORDER:t,isLE:e,BITS:i,BYTES:s,MASK:Bt(i),ZERO:j,ONE:C,create:o=>M(o,t),isValid:o=>{if(typeof o!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof o);return j<=o&&o<t},is0:o=>o===j,isOdd:o=>(o&C)===C,neg:o=>M(-o,t),eql:(o,l)=>o===l,sqr:o=>M(o*o,t),add:(o,l)=>M(o+l,t),sub:(o,l)=>M(o-l,t),mul:(o,l)=>M(o*l,t),pow:(o,l)=>Pe(f,o,l),div:(o,l)=>M(o*Zt(l,t),t),sqrN:o=>o*o,addN:(o,l)=>o+l,subN:(o,l)=>o-l,mulN:(o,l)=>o*l,inv:o=>Zt(o,t),sqrt:r.sqrt||(o=>(c||(c=je(t)),c(f,o))),toBytes:o=>e?ie(o,s):gt(o,s),fromBytes:o=>{if(o.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+o.length);return e?oe(o):ot(o)},invertBatch:o=>he(f,o),cmov:(o,l,g)=>g?l:o});return Object.freeze(f)}function ge(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function pe(t){const n=ge(t);return n+Math.ceil(n/2)}function De(t,n,e=!1){const r=t.length,i=ge(n),s=pe(n);if(r<16||r<s||r>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+r);const c=e?oe(t):ot(t),f=M(c,n-C)+C;return e?ie(f,i):gt(f,i)}const Xt=BigInt(0),zt=BigInt(1);function Ht(t,n){const e=n.negate();return t?e:n}function ye(t,n){if(!Number.isSafeInteger(t)||t<=0||t>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+t)}function qt(t,n){ye(t,n);const e=Math.ceil(n/t)+1,r=2**(t-1),i=2**t,s=Bt(t),c=BigInt(t);return{windows:e,windowSize:r,mask:s,maxNumber:i,shiftBy:c}}function Qt(t,n,e){const{windowSize:r,mask:i,maxNumber:s,shiftBy:c}=e;let f=Number(t&i),o=t>>c;f>r&&(f-=s,o+=zt);const l=n*r,g=l+Math.abs(f)-1,h=f===0,B=f<0,H=n%2!==0;return{nextN:o,offset:g,isZero:h,isNeg:B,isNegF:H,offsetF:l}}function Ge(t,n){if(!Array.isArray(t))throw new Error("array expected");t.forEach((e,r)=>{if(!(e instanceof n))throw new Error("invalid point at index "+r)})}function $e(t,n){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((e,r)=>{if(!n.isValid(e))throw new Error("invalid scalar at index "+r)})}const Lt=new WeakMap,be=new WeakMap;function Ut(t){return be.get(t)||1}function We(t,n){return{constTimeNegate:Ht,hasPrecomputes(e){return Ut(e)!==1},unsafeLadder(e,r,i=t.ZERO){let s=e;for(;r>Xt;)r&zt&&(i=i.add(s)),s=s.double(),r>>=zt;return i},precomputeWindow(e,r){const{windows:i,windowSize:s}=qt(r,n),c=[];let f=e,o=f;for(let l=0;l<i;l++){o=f,c.push(o);for(let g=1;g<s;g++)o=o.add(f),c.push(o);f=o.double()}return c},wNAF(e,r,i){let s=t.ZERO,c=t.BASE;const f=qt(e,n);for(let o=0;o<f.windows;o++){const{nextN:l,offset:g,isZero:h,isNeg:B,isNegF:H,offsetF:R}=Qt(i,o,f);i=l,h?c=c.add(Ht(H,r[R])):s=s.add(Ht(B,r[g]))}return{p:s,f:c}},wNAFUnsafe(e,r,i,s=t.ZERO){const c=qt(e,n);for(let f=0;f<c.windows&&i!==Xt;f++){const{nextN:o,offset:l,isZero:g,isNeg:h}=Qt(i,f,c);if(i=o,!g){const B=r[l];s=s.add(h?B.negate():B)}}return s},getPrecomputes(e,r,i){let s=Lt.get(r);return s||(s=this.precomputeWindow(r,e),e!==1&&Lt.set(r,i(s))),s},wNAFCached(e,r,i){const s=Ut(e);return this.wNAF(s,this.getPrecomputes(s,e,i),r)},wNAFCachedUnsafe(e,r,i,s){const c=Ut(e);return c===1?this.unsafeLadder(e,r,s):this.wNAFUnsafe(c,this.getPrecomputes(c,e,i),r,s)},setWindowSize(e,r){ye(r,n),be.set(e,r),Lt.delete(e)}}}function Fe(t,n,e,r){Ge(e,t),$e(r,n);const i=e.length,s=r.length;if(i!==s)throw new Error("arrays of points and scalars must have equal length");const c=t.ZERO,f=Be(BigInt(i));let o=1;f>12?o=f-3:f>4?o=f-2:f>0&&(o=2);const l=Bt(o),g=new Array(Number(l)+1).fill(c),h=Math.floor((n.BITS-1)/o)*o;let B=c;for(let H=h;H>=0;H-=o){g.fill(c);for(let p=0;p<s;p++){const Z=r[p],T=Number(Z>>BigInt(H)&l);g[T]=g[T].add(e[p])}let R=c;for(let p=g.length-1,Z=c;p>0;p--)Z=Z.add(g[p]),R=R.add(Z);if(B=B.add(R),H!==0)for(let p=0;p<o;p++)B=B.double()}return B}function me(t){return Ke(t.Fp),vt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...we(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}function Jt(t){t.lowS!==void 0&&dt("lowS",t.lowS),t.prehash!==void 0&&dt("prehash",t.prehash)}function Xe(t){const n=me(t);vt(n,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:e,Fp:r,a:i}=n;if(e){if(!r.eql(i,r.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...n})}class Qe extends Error{constructor(n=""){super(n)}}const F={Err:Qe,_tlv:{encode:(t,n)=>{const{Err:e}=F;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length&1)throw new e("tlv.encode: unpadded data");const r=n.length/2,i=yt(r);if(i.length/2&128)throw new e("tlv.encode: long form length too big");const s=r>127?yt(i.length/2|128):"";return yt(t)+s+i+n},decode(t,n){const{Err:e}=F;let r=0;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length<2||n[r++]!==t)throw new e("tlv.decode: wrong tlv");const i=n[r++],s=!!(i&128);let c=0;if(!s)c=i;else{const o=i&127;if(!o)throw new e("tlv.decode(long): indefinite length not supported");if(o>4)throw new e("tlv.decode(long): byte length is too big");const l=n.subarray(r,r+o);if(l.length!==o)throw new e("tlv.decode: length bytes not complete");if(l[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(const g of l)c=c<<8|g;if(r+=o,c<128)throw new e("tlv.decode(long): not minimal encoding")}const f=n.subarray(r,r+c);if(f.length!==c)throw new e("tlv.decode: wrong value length");return{v:f,l:n.subarray(r+c)}}},_int:{encode(t){const{Err:n}=F;if(t<X)throw new n("integer: negative integers are not allowed");let e=yt(t);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return e},decode(t){const{Err:n}=F;if(t[0]&128)throw new n("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return ot(t)}},toSig(t){const{Err:n,_int:e,_tlv:r}=F,i=K("signature",t),{v:s,l:c}=r.decode(48,i);if(c.length)throw new n("invalid signature: left bytes after parsing");const{v:f,l:o}=r.decode(2,s),{v:l,l:g}=r.decode(2,o);if(g.length)throw new n("invalid signature: left bytes after parsing");return{r:e.decode(f),s:e.decode(l)}},hexFromSig(t){const{_tlv:n,_int:e}=F,r=n.encode(2,e.encode(t.r)),i=n.encode(2,e.encode(t.s)),s=r+i;return n.encode(48,s)}};function Rt(t,n){return ht(gt(t,n))}const X=BigInt(0),_=BigInt(1);BigInt(2);const Tt=BigInt(3),Je=BigInt(4);function tn(t){const n=Xe(t),{Fp:e}=n,r=Pt(n.n,n.nBitLength),i=n.toBytes||((S,a,w)=>{const b=a.toAffine();return mt(Uint8Array.from([4]),e.toBytes(b.x),e.toBytes(b.y))}),s=n.fromBytes||(S=>{const a=S.subarray(1),w=e.fromBytes(a.subarray(0,e.BYTES)),b=e.fromBytes(a.subarray(e.BYTES,2*e.BYTES));return{x:w,y:b}});function c(S){const{a,b:w}=n,b=e.sqr(S),v=e.mul(b,S);return e.add(e.add(v,e.mul(S,a)),w)}function f(S,a){const w=e.sqr(a),b=c(S);return e.eql(w,b)}if(!f(n.Gx,n.Gy))throw new Error("bad curve params: generator point");const o=e.mul(e.pow(n.a,Tt),Je),l=e.mul(e.sqr(n.b),BigInt(27));if(e.is0(e.add(o,l)))throw new Error("bad curve params: a or b");function g(S){return Yt(S,_,n.n)}function h(S){const{allowedPrivateKeyLengths:a,nByteLength:w,wrapPrivateKey:b,n:v}=n;if(a&&typeof S!="bigint"){if(wt(S)&&(S=ht(S)),typeof S!="string"||!a.includes(S.length))throw new Error("invalid private key");S=S.padStart(w*2,"0")}let O;try{O=typeof S=="bigint"?S:ot(K("private key",S,w))}catch{throw new Error("invalid private key, expected hex or "+w+" bytes, got "+typeof S)}return b&&(O=M(O,v)),at("private key",O,_,v),O}function B(S){if(!(S instanceof p))throw new Error("ProjectivePoint expected")}const H=Wt((S,a)=>{const{px:w,py:b,pz:v}=S;if(e.eql(v,e.ONE))return{x:w,y:b};const O=S.is0();a==null&&(a=O?e.ONE:e.inv(v));const L=e.mul(w,a),q=e.mul(b,a),m=e.mul(v,a);if(O)return{x:e.ZERO,y:e.ZERO};if(!e.eql(m,e.ONE))throw new Error("invZ was invalid");return{x:L,y:q}}),R=Wt(S=>{if(S.is0()){if(n.allowInfinityPoint&&!e.is0(S.py))return;throw new Error("bad point: ZERO")}const{x:a,y:w}=S.toAffine();if(!e.isValid(a)||!e.isValid(w))throw new Error("bad point: x or y not FE");if(!f(a,w))throw new Error("bad point: equation left != right");if(!S.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class p{constructor(a,w,b){if(a==null||!e.isValid(a))throw new Error("x required");if(w==null||!e.isValid(w)||e.is0(w))throw new Error("y required");if(b==null||!e.isValid(b))throw new Error("z required");this.px=a,this.py=w,this.pz=b,Object.freeze(this)}static fromAffine(a){const{x:w,y:b}=a||{};if(!a||!e.isValid(w)||!e.isValid(b))throw new Error("invalid affine point");if(a instanceof p)throw new Error("projective point not allowed");const v=O=>e.eql(O,e.ZERO);return v(w)&&v(b)?p.ZERO:new p(w,b,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(a){const w=he(e,a.map(b=>b.pz));return a.map((b,v)=>b.toAffine(w[v])).map(p.fromAffine)}static fromHex(a){const w=p.fromAffine(s(K("pointHex",a)));return w.assertValidity(),w}static fromPrivateKey(a){return p.BASE.multiply(h(a))}static msm(a,w){return Fe(p,r,a,w)}_setWindowSize(a){D.setWindowSize(this,a)}assertValidity(){R(this)}hasEvenY(){const{y:a}=this.toAffine();if(e.isOdd)return!e.isOdd(a);throw new Error("Field doesn't support isOdd")}equals(a){B(a);const{px:w,py:b,pz:v}=this,{px:O,py:L,pz:q}=a,m=e.eql(e.mul(w,q),e.mul(O,v)),N=e.eql(e.mul(b,q),e.mul(L,v));return m&&N}negate(){return new p(this.px,e.neg(this.py),this.pz)}double(){const{a,b:w}=n,b=e.mul(w,Tt),{px:v,py:O,pz:L}=this;let q=e.ZERO,m=e.ZERO,N=e.ZERO,x=e.mul(v,v),k=e.mul(O,O),d=e.mul(L,L),u=e.mul(v,O);return u=e.add(u,u),N=e.mul(v,L),N=e.add(N,N),q=e.mul(a,N),m=e.mul(b,d),m=e.add(q,m),q=e.sub(k,m),m=e.add(k,m),m=e.mul(q,m),q=e.mul(u,q),N=e.mul(b,N),d=e.mul(a,d),u=e.sub(x,d),u=e.mul(a,u),u=e.add(u,N),N=e.add(x,x),x=e.add(N,x),x=e.add(x,d),x=e.mul(x,u),m=e.add(m,x),d=e.mul(O,L),d=e.add(d,d),x=e.mul(d,u),q=e.sub(q,x),N=e.mul(d,k),N=e.add(N,N),N=e.add(N,N),new p(q,m,N)}add(a){B(a);const{px:w,py:b,pz:v}=this,{px:O,py:L,pz:q}=a;let m=e.ZERO,N=e.ZERO,x=e.ZERO;const k=n.a,d=e.mul(n.b,Tt);let u=e.mul(w,O),y=e.mul(b,L),I=e.mul(v,q),E=e.add(w,b),A=e.add(O,L);E=e.mul(E,A),A=e.add(u,y),E=e.sub(E,A),A=e.add(w,v);let U=e.add(O,q);return A=e.mul(A,U),U=e.add(u,I),A=e.sub(A,U),U=e.add(b,v),m=e.add(L,q),U=e.mul(U,m),m=e.add(y,I),U=e.sub(U,m),x=e.mul(k,A),m=e.mul(d,I),x=e.add(m,x),m=e.sub(y,x),x=e.add(y,x),N=e.mul(m,x),y=e.add(u,u),y=e.add(y,u),I=e.mul(k,I),A=e.mul(d,A),y=e.add(y,I),I=e.sub(u,I),I=e.mul(k,I),A=e.add(A,I),u=e.mul(y,A),N=e.add(N,u),u=e.mul(U,A),m=e.mul(E,m),m=e.sub(m,u),u=e.mul(E,y),x=e.mul(U,x),x=e.add(x,u),new p(m,N,x)}subtract(a){return this.add(a.negate())}is0(){return this.equals(p.ZERO)}wNAF(a){return D.wNAFCached(this,a,p.normalizeZ)}multiplyUnsafe(a){const{endo:w,n:b}=n;at("scalar",a,X,b);const v=p.ZERO;if(a===X)return v;if(this.is0()||a===_)return this;if(!w||D.hasPrecomputes(this))return D.wNAFCachedUnsafe(this,a,p.normalizeZ);let{k1neg:O,k1:L,k2neg:q,k2:m}=w.splitScalar(a),N=v,x=v,k=this;for(;L>X||m>X;)L&_&&(N=N.add(k)),m&_&&(x=x.add(k)),k=k.double(),L>>=_,m>>=_;return O&&(N=N.negate()),q&&(x=x.negate()),x=new p(e.mul(x.px,w.beta),x.py,x.pz),N.add(x)}multiply(a){const{endo:w,n:b}=n;at("scalar",a,_,b);let v,O;if(w){const{k1neg:L,k1:q,k2neg:m,k2:N}=w.splitScalar(a);let{p:x,f:k}=this.wNAF(q),{p:d,f:u}=this.wNAF(N);x=D.constTimeNegate(L,x),d=D.constTimeNegate(m,d),d=new p(e.mul(d.px,w.beta),d.py,d.pz),v=x.add(d),O=k.add(u)}else{const{p:L,f:q}=this.wNAF(a);v=L,O=q}return p.normalizeZ([v,O])[0]}multiplyAndAddUnsafe(a,w,b){const v=p.BASE,O=(q,m)=>m===X||m===_||!q.equals(v)?q.multiplyUnsafe(m):q.multiply(m),L=O(this,w).add(O(a,b));return L.is0()?void 0:L}toAffine(a){return H(this,a)}isTorsionFree(){const{h:a,isTorsionFree:w}=n;if(a===_)return!0;if(w)return w(p,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:a,clearCofactor:w}=n;return a===_?this:w?w(p,this):this.multiplyUnsafe(n.h)}toRawBytes(a=!0){return dt("isCompressed",a),this.assertValidity(),i(p,this,a)}toHex(a=!0){return dt("isCompressed",a),ht(this.toRawBytes(a))}}p.BASE=new p(n.Gx,n.Gy,e.ONE),p.ZERO=new p(e.ZERO,e.ONE,e.ZERO);const{endo:Z,nBitLength:T}=n,D=We(p,Z?Math.ceil(T/2):T);return{CURVE:n,ProjectivePoint:p,normPrivateKeyToScalar:h,weierstrassEquation:c,isWithinCurveOrder:g}}function en(t){const n=me(t);return vt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function nn(t){const n=en(t),{Fp:e,n:r,nByteLength:i,nBitLength:s}=n,c=e.BYTES+1,f=2*e.BYTES+1;function o(d){return M(d,r)}function l(d){return Zt(d,r)}const{ProjectivePoint:g,normPrivateKeyToScalar:h,weierstrassEquation:B,isWithinCurveOrder:H}=tn({...n,toBytes(d,u,y){const I=u.toAffine(),E=e.toBytes(I.x),A=mt;return dt("isCompressed",y),y?A(Uint8Array.from([u.hasEvenY()?2:3]),E):A(Uint8Array.from([4]),E,e.toBytes(I.y))},fromBytes(d){const u=d.length,y=d[0],I=d.subarray(1);if(u===c&&(y===2||y===3)){const E=ot(I);if(!Yt(E,_,e.ORDER))throw new Error("Point is not on curve");const A=B(E);let U;try{U=e.sqrt(A)}catch(P){const V=P instanceof Error?": "+P.message:"";throw new Error("Point is not on curve"+V)}const z=(U&_)===_;return(y&1)===1!==z&&(U=e.neg(U)),{x:E,y:U}}else if(u===f&&y===4){const E=e.fromBytes(I.subarray(0,e.BYTES)),A=e.fromBytes(I.subarray(e.BYTES,2*e.BYTES));return{x:E,y:A}}else{const E=c,A=f;throw new Error("invalid Point, expected length of "+E+", or uncompressed "+A+", got "+u)}}});function R(d){const u=r>>_;return d>u}function p(d){return R(d)?o(-d):d}const Z=(d,u,y)=>ot(d.slice(u,y));class T{constructor(u,y,I){at("r",u,_,r),at("s",y,_,r),this.r=u,this.s=y,I!=null&&(this.recovery=I),Object.freeze(this)}static fromCompact(u){const y=i;return u=K("compactSignature",u,y*2),new T(Z(u,0,y),Z(u,y,2*y))}static fromDER(u){const{r:y,s:I}=F.toSig(K("DER",u));return new T(y,I)}assertValidity(){}addRecoveryBit(u){return new T(this.r,this.s,u)}recoverPublicKey(u){const{r:y,s:I,recovery:E}=this,A=v(K("msgHash",u));if(E==null||![0,1,2,3].includes(E))throw new Error("recovery id invalid");const U=E===2||E===3?y+n.n:y;if(U>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const z=(E&1)===0?"02":"03",$=g.fromHex(z+Rt(U,e.BYTES)),P=l(U),V=o(-A*P),it=o(I*P),Q=g.BASE.multiplyAndAddUnsafe($,V,it);if(!Q)throw new Error("point at infinify");return Q.assertValidity(),Q}hasHighS(){return R(this.s)}normalizeS(){return this.hasHighS()?new T(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return bt(this.toDERHex())}toDERHex(){return F.hexFromSig(this)}toCompactRawBytes(){return bt(this.toCompactHex())}toCompactHex(){const u=i;return Rt(this.r,u)+Rt(this.s,u)}}const D={isValidPrivateKey(d){try{return h(d),!0}catch{return!1}},normPrivateKeyToScalar:h,randomPrivateKey:()=>{const d=pe(n.n);return De(n.randomBytes(d),n.n)},precompute(d=8,u=g.BASE){return u._setWindowSize(d),u.multiply(BigInt(3)),u}};function S(d,u=!0){return g.fromPrivateKey(d).toRawBytes(u)}function a(d){if(typeof d=="bigint")return!1;if(d instanceof g)return!0;const y=K("key",d).length,I=e.BYTES,E=I+1,A=2*I+1;if(!(n.allowedPrivateKeyLengths||i===E))return y===E||y===A}function w(d,u,y=!0){if(a(d)===!0)throw new Error("first arg must be private key");if(a(u)===!1)throw new Error("second arg must be public key");return g.fromHex(u).multiply(h(d)).toRawBytes(y)}const b=n.bits2int||function(d){if(d.length>8192)throw new Error("input is too large");const u=ot(d),y=d.length*8-s;return y>0?u>>BigInt(y):u},v=n.bits2int_modN||function(d){return o(b(d))},O=Bt(s);function L(d){return at("num < 2^"+s,d,X,O),gt(d,i)}function q(d,u,y=m){if(["recovered","canonical"].some(et=>et in y))throw new Error("sign() legacy options not supported");const{hash:I,randomBytes:E}=n;let{lowS:A,prehash:U,extraEntropy:z}=y;A==null&&(A=!0),d=K("msgHash",d),Jt(y),U&&(d=K("prehashed msgHash",I(d)));const $=v(d),P=h(u),V=[L(P),L($)];if(z!=null&&z!==!1){const et=z===!0?E(e.BYTES):z;V.push(K("extraEntropy",et))}const it=mt(...V),Q=$;function At(et){const st=b(et);if(!H(st))return;const St=l(st),ut=g.BASE.multiply(st).toAffine(),nt=o(ut.x);if(nt===X)return;const lt=o(St*o(Q+nt*P));if(lt===X)return;let ct=(ut.x===nt?0:2)|Number(ut.y&_),Dt=lt;return A&&R(lt)&&(Dt=p(lt),ct^=1),new T(nt,Dt,ct)}return{seed:it,k2sig:At}}const m={lowS:n.lowS,prehash:!1},N={lowS:n.lowS,prehash:!1};function x(d,u,y=m){const{seed:I,k2sig:E}=q(d,u,y),A=n;return ve(A.hash.outputLen,A.nByteLength,A.hmac)(I,E)}g.BASE._setWindowSize(8);function k(d,u,y,I=N){const E=d;u=K("msgHash",u),y=K("publicKey",y);const{lowS:A,prehash:U,format:z}=I;if(Jt(I),"strict"in I)throw new Error("options.strict was renamed to lowS");if(z!==void 0&&z!=="compact"&&z!=="der")throw new Error("format must be compact or der");const $=typeof E=="string"||wt(E),P=!$&&!z&&typeof E=="object"&&E!==null&&typeof E.r=="bigint"&&typeof E.s=="bigint";if(!$&&!P)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let V,it;try{if(P&&(V=new T(E.r,E.s)),$){try{z!=="compact"&&(V=T.fromDER(E))}catch(ct){if(!(ct instanceof F.Err))throw ct}!V&&z!=="der"&&(V=T.fromCompact(E))}it=g.fromHex(y)}catch{return!1}if(!V||A&&V.hasHighS())return!1;U&&(u=n.hash(u));const{r:Q,s:At}=V,et=v(u),st=l(At),St=o(et*st),ut=o(Q*st),nt=g.BASE.multiplyAndAddUnsafe(it,St,ut)?.toAffine();return nt?o(nt.x)===Q:!1}return{CURVE:n,getPublicKey:S,getSharedSecret:w,sign:x,verify:k,ProjectivePoint:g,Signature:T,utils:D}}function rn(t){return{hash:t,hmac:(n,...e)=>fe(t,n,He(...e)),randomBytes:Le}}function on(t,n){const e=r=>nn({...t,...rn(r)});return{...e(n),create:e}}const xe=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),te=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),sn=BigInt(0),cn=BigInt(1),Ct=BigInt(2),ee=(t,n)=>(t+n/Ct)/n;function fn(t){const n=xe,e=BigInt(3),r=BigInt(6),i=BigInt(11),s=BigInt(22),c=BigInt(23),f=BigInt(44),o=BigInt(88),l=t*t*t%n,g=l*l*t%n,h=Y(g,e,n)*g%n,B=Y(h,e,n)*g%n,H=Y(B,Ct,n)*l%n,R=Y(H,i,n)*H%n,p=Y(R,s,n)*R%n,Z=Y(p,f,n)*p%n,T=Y(Z,o,n)*Z%n,D=Y(T,f,n)*p%n,S=Y(D,e,n)*g%n,a=Y(S,c,n)*R%n,w=Y(a,r,n)*l%n,b=Y(w,Ct,n);if(!Vt.eql(Vt.sqr(b),t))throw new Error("Cannot find square root");return b}const Vt=Pt(xe,void 0,void 0,{sqrt:fn}),an=on({a:sn,b:BigInt(7),Fp:Vt,n:te,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const n=te,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-cn*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=e,c=BigInt("0x100000000000000000000000000000000"),f=ee(s*t,n),o=ee(-r*t,n);let l=M(t-f*e-o*i,n),g=M(-f*r-o*s,n);const h=l>c,B=g>c;if(h&&(l=n-l),B&&(g=n-g),l>c||g>c)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:h,k1:l,k2neg:B,k2:g}}}},ze);export{an as secp256k1};
