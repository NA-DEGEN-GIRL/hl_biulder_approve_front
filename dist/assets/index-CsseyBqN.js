(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))r(o);new MutationObserver(o=>{for(const a of o)if(a.type==="childList")for(const u of a.addedNodes)u.tagName==="LINK"&&u.rel==="modulepreload"&&r(u)}).observe(document,{childList:!0,subtree:!0});function n(o){const a={};return o.integrity&&(a.integrity=o.integrity),o.referrerPolicy&&(a.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?a.credentials="include":o.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function r(o){if(o.ep)return;o.ep=!0;const a=n(o);fetch(o.href,a)}})();class vn extends Error{constructor(t,n){super(t,n),this.name="HyperliquidError"}}let On;function Xs(e){return{lang:e?.lang??On?.lang,message:e?.message,abortEarly:e?.abortEarly??On?.abortEarly,abortPipeEarly:e?.abortPipeEarly??On?.abortPipeEarly}}let Aa;function va(e){return Aa?.get(e)}let qa;function Ta(e){return qa?.get(e)}let Ea;function Sa(e,t){return Ea?.get(e)?.get(t)}function ln(e){const t=typeof e;return t==="string"?`"${e}"`:t==="number"||t==="bigint"||t==="boolean"?`${e}`:t==="object"||t==="function"?(e&&Object.getPrototypeOf(e)?.constructor?.name)??"null":t}function G(e,t,n,r,o){const a=o&&"input"in o?o.input:n.value,u=o?.expected??e.expects??null,c=o?.received??ln(a),d={kind:e.kind,type:e.type,input:a,expected:u,received:c,message:`Invalid ${t}: ${u?`Expected ${u} but r`:"R"}eceived ${c}`,requirement:e.requirement,path:o?.path,issues:o?.issues,lang:r.lang,abortEarly:r.abortEarly,abortPipeEarly:r.abortPipeEarly},p=e.kind==="schema",f=o?.message??e.message??Sa(e.reference,d.lang)??(p?Ta(d.lang):null)??r.message??va(d.lang);f!==void 0&&(d.message=typeof f=="function"?f(d):f),p&&(n.typed=!1),n.issues?n.issues.push(d):n.issues=[d]}function te(e){return{version:1,vendor:"valibot",validate(t){return e["~run"]({value:t},Xs())}}}function Ca(e,t){const n=[...new Set(e)];return n.length>1?`(${n.join(` ${t} `)})`:n[0]??"never"}function Ia(e){if(e.path){let t="";for(const n of e.path)if(typeof n.key=="string"||typeof n.key=="number")t?t+=`.${n.key}`:t+=n.key;else return null;return t}return null}const Pa=/^(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])(?:\.(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])){3}$|^(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:|(?:[\da-f]{1,4}:){1,6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,5}(?::[\da-f]{1,4}){1,2}|(?:[\da-f]{1,4}:){1,4}(?::[\da-f]{1,4}){1,3}|(?:[\da-f]{1,4}:){1,3}(?::[\da-f]{1,4}){1,4}|(?:[\da-f]{1,4}:){1,2}(?::[\da-f]{1,4}){1,5}|[\da-f]{1,4}:(?::[\da-f]{1,4}){1,6}|:(?:(?::[\da-f]{1,4}){1,7}|:)|fe80:(?::[\da-f]{0,4}){0,4}%[\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d)|(?:[\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d))$/iu;function Yt(e,t){return{kind:"validation",type:"check",reference:Yt,async:!1,expects:null,requirement:e,message:t,"~run"(n,r){return n.typed&&!this.requirement(n.value)&&G(this,"input",n,r),n}}}function i(e){return{kind:"metadata",type:"description",reference:i,description:e}}function Er(e){return{kind:"validation",type:"integer",reference:Er,async:!1,expects:null,requirement:Number.isInteger,message:e,"~run"(t,n){return t.typed&&!this.requirement(t.value)&&G(this,"integer",t,n),t}}}function Qn(e){return{kind:"validation",type:"ip",reference:Qn,async:!1,expects:null,requirement:Pa,message:e,"~run"(t,n){return t.typed&&!this.requirement.test(t.value)&&G(this,"IP",t,n),t}}}function ye(e,t){return{kind:"validation",type:"length",reference:ye,async:!1,expects:`${e}`,requirement:e,message:t,"~run"(n,r){return n.typed&&n.value.length!==this.requirement&&G(this,"length",n,r,{received:`${n.value.length}`}),n}}}function $e(e,t){return{kind:"validation",type:"min_length",reference:$e,async:!1,expects:`>=${e}`,requirement:e,message:t,"~run"(n,r){return n.typed&&n.value.length<this.requirement&&G(this,"length",n,r,{received:`${n.value.length}`}),n}}}function qn(e,t){return{kind:"validation",type:"min_value",reference:qn,async:!1,expects:`>=${e instanceof Date?e.toJSON():ln(e)}`,requirement:e,message:t,"~run"(n,r){return n.typed&&!(n.value>=this.requirement)&&G(this,"value",n,r,{received:n.value instanceof Date?n.value.toJSON():ln(n.value)}),n}}}function Ks(e,t){return{kind:"transformation",type:"parse_json",reference:Ks,config:e,message:t,async:!1,"~run"(n,r){try{n.value=JSON.parse(n.value,this.config?.reviver)}catch(o){if(o instanceof Error)G(this,"JSON",n,r,{received:`"${o.message}"`}),n.typed=!1;else throw o}return n}}}function Zt(e,t){return{kind:"validation",type:"regex",reference:Zt,async:!1,expects:`${e}`,requirement:e,message:t,"~run"(n,r){return n.typed&&!this.requirement.test(n.value)&&G(this,"format",n,r),n}}}function Sr(e){return{kind:"validation",type:"safe_integer",reference:Sr,async:!1,expects:null,requirement:Number.isSafeInteger,message:e,"~run"(t,n){return t.typed&&!this.requirement(t.value)&&G(this,"safe integer",t,n),t}}}function er(e,t){return{kind:"transformation",type:"stringify_json",reference:er,message:t,config:e,async:!1,"~run"(n,r){try{const o=JSON.stringify(n.value,this.config?.replacer,this.config?.space);o===void 0&&(G(this,"JSON",n,r),n.typed=!1),n.value=o}catch(o){if(o instanceof Error)G(this,"JSON",n,r,{received:`"${o.message}"`}),n.typed=!1;else throw o}return n}}}function De(e){return{kind:"transformation",type:"transform",reference:De,async:!1,operation:e,"~run"(t){return t.value=this.operation(t.value),t}}}function Ys(){return{kind:"transformation",type:"trim",reference:Ys,async:!1,"~run"(e){return e.value=e.value.trim(),e}}}function ka(e,t,n){return typeof e.fallback=="function"?e.fallback(t,n):e.fallback}function Tn(e,t,n){return typeof e.default=="function"?e.default(t,n):e.default}function fe(e,t){return!e["~run"]({value:t},{abortEarly:!0}).issues}function Y(e,t){return{kind:"schema",type:"array",reference:Y,expects:"Array",async:!1,item:e,message:t,get"~standard"(){return te(this)},"~run"(n,r){const o=n.value;if(Array.isArray(o)){n.typed=!0,n.value=[];for(let a=0;a<o.length;a++){const u=o[a],c=this.item["~run"]({value:u},r);if(c.issues){const d={type:"array",origin:"value",input:o,key:a,value:u};for(const p of c.issues)p.path?p.path.unshift(d):p.path=[d],n.issues?.push(p);if(n.issues||(n.issues=c.issues),r.abortEarly){n.typed=!1;break}}c.typed||(n.typed=!1),n.value.push(c.value)}}else G(this,"type",n,r);return n}}}function N(e){return{kind:"schema",type:"boolean",reference:N,expects:"boolean",async:!1,message:e,get"~standard"(){return te(this)},"~run"(t,n){return typeof t.value=="boolean"?t.typed=!0:G(this,"type",t,n),t}}}function pe(e){return{kind:"schema",type:"function",reference:pe,expects:"Function",async:!1,message:e,get"~standard"(){return te(this)},"~run"(t,n){return typeof t.value=="function"?t.typed=!0:G(this,"type",t,n),t}}}function h(e,t){return{kind:"schema",type:"literal",reference:h,expects:ln(e),async:!1,literal:e,message:t,get"~standard"(){return te(this)},"~run"(n,r){return n.value===this.literal?n.typed=!0:G(this,"type",n,r),n}}}function vt(e){return{kind:"schema",type:"null",reference:vt,expects:"null",async:!1,message:e,get"~standard"(){return te(this)},"~run"(t,n){return t.value===null?t.typed=!0:G(this,"type",t,n),t}}}function se(e,t){return{kind:"schema",type:"nullable",reference:se,expects:`(${e.expects} | null)`,async:!1,wrapped:e,default:t,get"~standard"(){return te(this)},"~run"(n,r){return n.value===null&&(this.default!==void 0&&(n.value=Tn(this,n,r)),n.value===null)?(n.typed=!0,n):this.wrapped["~run"](n,r)}}}function de(e,t){return{kind:"schema",type:"nullish",reference:de,expects:`(${e.expects} | null | undefined)`,async:!1,wrapped:e,default:t,get"~standard"(){return te(this)},"~run"(n,r){return(n.value===null||n.value===void 0)&&(this.default!==void 0&&(n.value=Tn(this,n,r)),n.value===null||n.value===void 0)?(n.typed=!0,n):this.wrapped["~run"](n,r)}}}function tt(e){return{kind:"schema",type:"number",reference:tt,expects:"number",async:!1,message:e,get"~standard"(){return te(this)},"~run"(t,n){return typeof t.value=="number"&&!isNaN(t.value)?t.typed=!0:G(this,"type",t,n),t}}}function l(e,t){return{kind:"schema",type:"object",reference:l,expects:"Object",async:!1,entries:e,message:t,get"~standard"(){return te(this)},"~run"(n,r){const o=n.value;if(o&&typeof o=="object"){n.typed=!0,n.value={};for(const a in this.entries){const u=this.entries[a];if(a in o||(u.type==="exact_optional"||u.type==="optional"||u.type==="nullish")&&u.default!==void 0){const c=a in o?o[a]:Tn(u),d=u["~run"]({value:c},r);if(d.issues){const p={type:"object",origin:"value",input:o,key:a,value:c};for(const f of d.issues)f.path?f.path.unshift(p):f.path=[p],n.issues?.push(f);if(n.issues||(n.issues=d.issues),r.abortEarly){n.typed=!1;break}}d.typed||(n.typed=!1),n.value[a]=d.value}else if(u.fallback!==void 0)n.value[a]=ka(u);else if(u.type!=="exact_optional"&&u.type!=="optional"&&u.type!=="nullish"&&(G(this,"key",n,r,{input:void 0,expected:`"${a}"`,path:[{type:"object",origin:"key",input:o,key:a,value:o[a]}]}),r.abortEarly))break}}else G(this,"type",n,r);return n}}}function E(e,t){return{kind:"schema",type:"optional",reference:E,expects:`(${e.expects} | undefined)`,async:!1,wrapped:e,default:t,get"~standard"(){return te(this)},"~run"(n,r){return n.value===void 0&&(this.default!==void 0&&(n.value=Tn(this,n,r)),n.value===void 0)?(n.typed=!0,n):this.wrapped["~run"](n,r)}}}function k(e){return{kind:"schema",type:"string",reference:k,expects:"string",async:!1,message:e,get"~standard"(){return te(this)},"~run"(t,n){return typeof t.value=="string"?t.typed=!0:G(this,"type",t,n),t}}}function le(e,t){return{kind:"schema",type:"tuple",reference:le,expects:"Array",async:!1,items:e,message:t,get"~standard"(){return te(this)},"~run"(n,r){const o=n.value;if(Array.isArray(o)){n.typed=!0,n.value=[];for(let a=0;a<this.items.length;a++){const u=o[a],c=this.items[a]["~run"]({value:u},r);if(c.issues){const d={type:"array",origin:"value",input:o,key:a,value:u};for(const p of c.issues)p.path?p.path.unshift(d):p.path=[d],n.issues?.push(p);if(n.issues||(n.issues=c.issues),r.abortEarly){n.typed=!1;break}}c.typed||(n.typed=!1),n.value.push(c.value)}}else G(this,"type",n,r);return n}}}function is(e){let t;if(e)for(const n of e)t?t.push(...n.issues):t=n.issues;return t}function M(e,t){return{kind:"schema",type:"union",reference:M,expects:Ca(e.map(n=>n.expects),"|"),async:!1,options:e,message:t,get"~standard"(){return te(this)},"~run"(n,r){let o,a,u;for(const c of this.options){const d=c["~run"]({value:n.value},r);if(d.typed)if(d.issues)a?a.push(d):a=[d];else{o=d;break}else u?u.push(d):u=[d]}if(o)return o;if(a){if(a.length===1)return a[0];G(this,"type",n,r,{issues:is(a)}),n.typed=!0}else{if(u?.length===1)return u[0];G(this,"type",n,r,{issues:is(u)})}return n}}}function s(...e){return{...e[0],pipe:e,get"~standard"(){return te(this)},"~run"(t,n){for(const r of e)if(r.kind!=="metadata"){if(t.issues&&(r.kind==="schema"||r.kind==="transformation")){t.typed=!1;break}(!t.issues||!n.abortEarly&&!n.abortPipeEarly)&&(t=r["~run"](t,n))}return t}}}function Ra(e,t,n){const r=e["~run"]({value:t},Xs(n));return{typed:r.typed,success:!r.issues,output:r.value,issues:r.issues}}function Ua(e,t){const n=r=>Ra(e,r,t);return n.schema=e,n.config=t,n}function Ba(e){let t="";for(const n of e){t&&(t+=`
`),t+=`× ${n.message}`;const r=Ia(n);r&&(t+=`
  → at ${r}`)}return t}const j=s(M([k(),tt()]),De(String),k(),Ys(),Zt(/^[0-9]+(\.[0-9]+)?$/),De(e=>$a(e))),tr=s(M([k(),tt()]),De(Number),tt(),Er(),Sr()),g=s(M([k(),tt()]),De(Number),tt(),Er(),Sr(),qn(0)),z=s(k(),Zt(/^0[xX][0-9a-fA-F]+$/),De(e=>e.toLowerCase())),q=s(z,ye(42)),Cr=s(k(),Zt(/^[^:]+:0x[0-9a-fA-F]+$/),De(e=>e)),Zs=s(k(),Zt(/^[0-9]+(\.[0-9]+)?%$/),De(e=>e));function $a(e){return e.trim().replace(/^(-?)0+(?=\d)/,"$1").replace(/(\.\d*?)0+$/,"$1").replace(/\.$/,"")}class Da extends vn{constructor(t){super(t),this.name="SchemaError"}}function w(e){const t=Ua(e),n=r=>{const o=t(r);if(o.issues)throw new Da(`
`+Ba(o.issues));return o.output};return n.schema=e,n.config=void 0,n}class Js extends vn{constructor(t,n){super(t,n),this.name="TransportError"}}const Qs={any:AbortSignal.any?e=>AbortSignal.any(e):e=>{const t=new AbortController;for(const n of e){if(n.aborted){t.abort(n.reason);break}n.addEventListener("abort",()=>t.abort(n.reason),{once:!0,signal:t.signal})}return t.signal},timeout:AbortSignal.timeout?e=>AbortSignal.timeout(e):e=>{const t=new AbortController;return setTimeout(()=>t.abort(new DOMException("Signal timed out.","TimeoutError")),e),t.signal}};let Nn=class extends Js{response;body;constructor(t,n){const{response:r,body:o}=t??{};let a;r?(a=`${r.status} ${r.statusText}`.trim(),o&&(a+=` - ${o}`)):a=`Unknown error while making an HTTP request: ${n?.cause}`,super(a,n),this.name="HttpRequestError",this.response=r,this.body=o}};class ei{isTestnet;timeout;server;fetchOptions;onRequest;onResponse;onError;constructor(t){this.isTestnet=t?.isTestnet??!1,this.timeout=t?.timeout===void 0?1e4:t.timeout,this.server={mainnet:{api:t?.server?.mainnet?.api??"https://api.hyperliquid.xyz",rpc:t?.server?.mainnet?.rpc??"https://rpc.hyperliquid.xyz"},testnet:{api:t?.server?.testnet?.api??"https://api.hyperliquid-testnet.xyz",rpc:t?.server?.testnet?.rpc??"https://rpc.hyperliquid-testnet.xyz"}},this.fetchOptions=t?.fetchOptions??{},this.onRequest=t?.onRequest,this.onResponse=t?.onResponse,this.onError=t?.onError}async request(t,n,r){try{const o=new URL(t,this.server[this.isTestnet?"testnet":"mainnet"][t==="explorer"?"rpc":"api"]),a=Fa({body:JSON.stringify(n),headers:{"Accept-Encoding":"gzip, deflate, br, zstd","Content-Type":"application/json"},keepalive:!0,method:"POST",signal:this.timeout?Qs.timeout(this.timeout):void 0},this.fetchOptions,{signal:r});let u=new Request(o,a);if(this.onRequest){const p=await this.onRequest(u);p instanceof Request&&(u=p)}let c=await fetch(u).catch(async p=>{if(this.onError){const f=await this.onError(p);f instanceof Error&&(p=f)}throw p});if(this.onResponse){const p=await this.onResponse(c);p instanceof Response&&(c=p)}if(!c.ok||!c.headers.get("Content-Type")?.includes("application/json")){const p=await c.text().catch(()=>{});throw new Nn({response:c,body:p})}const d=await c.json();if(d?.type==="error")throw new Nn({response:c,body:d?.message});return d}catch(o){throw o instanceof Js?o:new Nn(void 0,{cause:o})}}}function Ma(...e){if(e.length===0||e.length===1)return new Headers(e[0]);const t=new Headers;for(const n of e){const r=Symbol.iterator in n?n:Object.entries(n);for(const[o,a]of r)t.set(o,a)}return t}function Fa(...e){const t=e.reduce((o,a)=>({...o,...a}),{}),n=e.map(o=>o.headers).filter(o=>typeof o=="object");n.length>0&&(t.headers=Ma(...n));const r=e.map(o=>o.signal).filter(o=>o instanceof AbortSignal);return r.length>0&&(t.signal=r.length>1?Qs.any(r):r[0]),t}const tn=BigInt(2**32-1),os=BigInt(32);function Oa(e,t=!1){return t?{h:Number(e&tn),l:Number(e>>os&tn)}:{h:Number(e>>os&tn)|0,l:Number(e&tn)|0}}function Na(e,t=!1){const n=e.length;let r=new Uint32Array(n),o=new Uint32Array(n);for(let a=0;a<n;a++){const{h:u,l:c}=Oa(e[a],t);[r[a],o[a]]=[u,c]}return[r,o]}const La=(e,t,n)=>e<<n|t>>>32-n,za=(e,t,n)=>t<<n|e>>>32-n,_a=(e,t,n)=>t<<n-32|e>>>64-n,Ha=(e,t,n)=>e<<n-32|t>>>64-n;function Va(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function as(e,t=""){if(!Number.isSafeInteger(e)||e<0){const n=t&&`"${t}" `;throw new Error(`${n}expected integer >= 0, got ${e}`)}}function qt(e,t,n=""){const r=Va(e),o=e?.length;if(!r||t!==void 0){const u=n&&`"${n}" `,c="",d=r?`length=${o}`:`type=${typeof e}`;throw new Error(u+"expected Uint8Array"+c+", got "+d)}return e}function us(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function Ga(e,t){qt(e,void 0,"digestInto() output");const n=t.outputLen;if(e.length<n)throw new Error('"digestInto() output" expected to be of length >='+n)}function ja(e){return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}function ti(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}const Wa=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function Xa(e){return e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255}function Ka(e){for(let t=0;t<e.length;t++)e[t]=Xa(e[t]);return e}const cs=Wa?e=>e:Ka,ni=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Ya=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function Za(e){if(qt(e),ni)return e.toHex();let t="";for(let n=0;n<e.length;n++)t+=Ya[e[n]];return t}const qe={_0:48,_9:57,A:65,F:70,a:97,f:102};function ds(e){if(e>=qe._0&&e<=qe._9)return e-qe._0;if(e>=qe.A&&e<=qe.F)return e-(qe.A-10);if(e>=qe.a&&e<=qe.f)return e-(qe.a-10)}function Ja(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);if(ni)return Uint8Array.fromHex(e);const t=e.length,n=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(n);for(let o=0,a=0;o<n;o++,a+=2){const u=ds(e.charCodeAt(a)),c=ds(e.charCodeAt(a+1));if(u===void 0||c===void 0){const d=e[a]+e[a+1];throw new Error('hex string expected, got non-hex character "'+d+'" at index '+a)}r[o]=u*16+c}return r}function Qa(...e){let t=0;for(let r=0;r<e.length;r++){const o=e[r];qt(o),t+=o.length}const n=new Uint8Array(t);for(let r=0,o=0;r<e.length;r++){const a=e[r];n.set(a,o),o+=a.length}return n}function e0(e,t={}){const n=(o,a)=>e(a).update(o).digest(),r=e(void 0);return n.outputLen=r.outputLen,n.blockLen=r.blockLen,n.create=o=>e(o),Object.assign(n,t),Object.freeze(n)}const t0=BigInt(0),ht=BigInt(1),n0=BigInt(2),r0=BigInt(7),s0=BigInt(256),i0=BigInt(113),ri=[],si=[],ii=[];for(let e=0,t=ht,n=1,r=0;e<24;e++){[n,r]=[r,(2*n+3*r)%5],ri.push(2*(5*r+n)),si.push((e+1)*(e+2)/2%64);let o=t0;for(let a=0;a<7;a++)t=(t<<ht^(t>>r0)*i0)%s0,t&n0&&(o^=ht<<(ht<<BigInt(a))-ht);ii.push(o)}const oi=Na(ii,!0),o0=oi[0],a0=oi[1],ls=(e,t,n)=>n>32?_a(e,t,n):La(e,t,n),fs=(e,t,n)=>n>32?Ha(e,t,n):za(e,t,n);function u0(e,t=24){const n=new Uint32Array(10);for(let r=24-t;r<24;r++){for(let u=0;u<10;u++)n[u]=e[u]^e[u+10]^e[u+20]^e[u+30]^e[u+40];for(let u=0;u<10;u+=2){const c=(u+8)%10,d=(u+2)%10,p=n[d],f=n[d+1],m=ls(p,f,1)^n[c],y=fs(p,f,1)^n[c+1];for(let b=0;b<50;b+=10)e[u+b]^=m,e[u+b+1]^=y}let o=e[2],a=e[3];for(let u=0;u<24;u++){const c=si[u],d=ls(o,a,c),p=fs(o,a,c),f=ri[u];o=e[f],a=e[f+1],e[f]=d,e[f+1]=p}for(let u=0;u<50;u+=10){for(let c=0;c<10;c++)n[c]=e[u+c];for(let c=0;c<10;c++)e[u+c]^=~n[(c+2)%10]&n[(c+4)%10]}e[0]^=o0[r],e[1]^=a0[r]}ti(n)}let c0=class ai{state;pos=0;posOut=0;finished=!1;state32;destroyed=!1;blockLen;suffix;outputLen;enableXOF=!1;rounds;constructor(t,n,r,o=!1,a=24){if(this.blockLen=t,this.suffix=n,this.outputLen=r,this.enableXOF=o,this.rounds=a,as(r,"outputLen"),!(0<t&&t<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=ja(this.state)}clone(){return this._cloneInto()}keccak(){cs(this.state32),u0(this.state32,this.rounds),cs(this.state32),this.posOut=0,this.pos=0}update(t){us(this),qt(t);const{blockLen:n,state:r}=this,o=t.length;for(let a=0;a<o;){const u=Math.min(n-this.pos,o-a);for(let c=0;c<u;c++)r[this.pos++]^=t[a++];this.pos===n&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:n,pos:r,blockLen:o}=this;t[r]^=n,(n&128)!==0&&r===o-1&&this.keccak(),t[o-1]^=128,this.keccak()}writeInto(t){us(this,!1),qt(t),this.finish();const n=this.state,{blockLen:r}=this;for(let o=0,a=t.length;o<a;){this.posOut>=r&&this.keccak();const u=Math.min(r-this.posOut,a-o);t.set(n.subarray(this.posOut,this.posOut+u),o),this.posOut+=u,o+=u}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return as(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(Ga(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,ti(this.state)}_cloneInto(t){const{blockLen:n,suffix:r,outputLen:o,rounds:a,enableXOF:u}=this;return t||=new ai(n,r,o,u,a),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=a,t.suffix=r,t.outputLen=o,t.enableXOF=u,t.destroyed=this.destroyed,t}};const d0=(e,t,n,r={})=>e0(()=>new c0(t,e,n),r),Ue=d0(1,136,32);const ui={p:0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn,n:0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n,h:1n,a:0n,b:7n,Gx:0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,Gy:0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n},{p:Ge,n:nt,Gx:l0,Gy:f0,b:ci}=ui,xe=32,Tt=64,di={publicKey:xe+1,publicKeyUncompressed:Tt+1,signature:Tt},p0=(...e)=>{"captureStackTrace"in Error&&typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(...e)},V=(e="")=>{const t=new Error(e);throw p0(t,V),t},h0=e=>typeof e=="bigint",y0=e=>typeof e=="string",m0=e=>e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array",Le=(e,t,n="")=>{const r=m0(e),o=e?.length,a=t!==void 0;if(!r||a&&o!==t){const u=n&&`"${n}" `,c=a?` of length ${t}`:"",d=r?`length=${o}`:`type=${typeof e}`;V(u+"expected Uint8Array"+c+", got "+d)}return e},Me=e=>new Uint8Array(e),li=(e,t)=>e.toString(16).padStart(t,"0"),Ir=e=>Array.from(Le(e)).map(t=>li(t,2)).join(""),Te={_0:48,_9:57,A:65,F:70,a:97,f:102},ps=e=>{if(e>=Te._0&&e<=Te._9)return e-Te._0;if(e>=Te.A&&e<=Te.F)return e-(Te.A-10);if(e>=Te.a&&e<=Te.f)return e-(Te.a-10)},Pr=e=>{const t="hex invalid";if(!y0(e))return V(t);const n=e.length,r=n/2;if(n%2)return V(t);const o=Me(r);for(let a=0,u=0;a<r;a++,u+=2){const c=ps(e.charCodeAt(u)),d=ps(e.charCodeAt(u+1));if(c===void 0||d===void 0)return V(t);o[a]=c*16+d}return o},fi=()=>globalThis?.crypto,hs=()=>fi()?.subtle??V("crypto.subtle must be defined, consider polyfill"),We=(...e)=>{const t=Me(e.reduce((r,o)=>r+Le(o).length,0));let n=0;return e.forEach(r=>{t.set(r,n),n+=r.length}),t},pi=(e=xe)=>fi().getRandomValues(Me(e)),Et=BigInt,Jt=(e,t,n,r="bad number: out of range")=>h0(e)&&t<=e&&e<n?e:V(r),P=(e,t=Ge)=>{const n=e%t;return n>=0n?n:t+n},bt=e=>P(e,nt),kr=(e,t)=>{(e===0n||t<=0n)&&V("no inverse n="+e+" mod="+t);let n=P(e,t),r=t,o=0n,a=1n;for(;n!==0n;){const u=r/n,c=r%n,d=o-a*u;r=n,n=c,o=a,a=d}return r===1n?P(o,t):V("no inverse")},g0=e=>{const t=Ur[e];return typeof t!="function"&&V("hashes."+e+" not set"),t},Ln=e=>e instanceof ue?e:V("Point expected"),hi=e=>P(P(e*e)*e+ci),ys=e=>Jt(e,0n,Ge),un=e=>Jt(e,1n,Ge),nr=e=>Jt(e,1n,nt),rr=e=>(e&1n)===0n,En=e=>Uint8Array.of(e),b0=e=>En(rr(e)?2:3),w0=e=>{const t=hi(un(e));let n=1n;for(let r=t,o=(Ge+1n)/4n;o>0n;o>>=1n)o&1n&&(n=n*r%Ge),r=r*r%Ge;return P(n*n)===t?n:V("sqrt invalid")};class ue{static BASE;static ZERO;X;Y;Z;constructor(t,n,r){this.X=ys(t),this.Y=un(n),this.Z=ys(r),Object.freeze(this)}static CURVE(){return ui}static fromAffine(t){const{x:n,y:r}=t;return n===0n&&r===0n?He:new ue(n,r,1n)}static fromBytes(t){Le(t);const{publicKey:n,publicKeyUncompressed:r}=di;let o;const a=t.length,u=t[0],c=t.subarray(1),d=fn(c,0,xe);if(a===n&&(u===2||u===3)){let p=w0(d);const f=rr(p);rr(Et(u))!==f&&(p=P(-p)),o=new ue(d,p,1n)}return a===r&&u===4&&(o=new ue(d,fn(c,xe,Tt),1n)),o?o.assertValidity():V("bad point: not on curve")}static fromHex(t){return ue.fromBytes(Pr(t))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}equals(t){const{X:n,Y:r,Z:o}=this,{X:a,Y:u,Z:c}=Ln(t),d=P(n*c),p=P(a*o),f=P(r*c),m=P(u*o);return d===p&&f===m}is0(){return this.equals(He)}negate(){return new ue(this.X,P(-this.Y),this.Z)}double(){return this.add(this)}add(t){const{X:n,Y:r,Z:o}=this,{X:a,Y:u,Z:c}=Ln(t),d=0n,p=ci;let f=0n,m=0n,y=0n;const b=P(p*3n);let x=P(n*a),T=P(r*u),A=P(o*c),S=P(n+r),C=P(a+u);S=P(S*C),C=P(x+T),S=P(S-C),C=P(n+o);let I=P(a+c);return C=P(C*I),I=P(x+A),C=P(C-I),I=P(r+o),f=P(u+c),I=P(I*f),f=P(T+A),I=P(I-f),y=P(d*C),f=P(b*A),y=P(f+y),f=P(T-y),y=P(T+y),m=P(f*y),T=P(x+x),T=P(T+x),A=P(d*A),C=P(b*C),T=P(T+A),A=P(x-A),A=P(d*A),C=P(C+A),x=P(T*C),m=P(m+x),x=P(I*C),f=P(S*f),f=P(f-x),x=P(S*T),y=P(I*y),y=P(y+x),new ue(f,m,y)}subtract(t){return this.add(Ln(t).negate())}multiply(t,n=!0){if(!n&&t===0n)return He;if(nr(t),t===1n)return this;if(this.equals(Xe))return N0(t).p;let r=He,o=Xe;for(let a=this;t>0n;a=a.double(),t>>=1n)t&1n?r=r.add(a):n&&(o=o.add(a));return r}multiplyUnsafe(t){return this.multiply(t,!1)}toAffine(){const{X:t,Y:n,Z:r}=this;if(this.equals(He))return{x:0n,y:0n};if(r===1n)return{x:t,y:n};const o=kr(r,Ge);return P(r*o)!==1n&&V("inverse invalid"),{x:P(t*o),y:P(n*o)}}assertValidity(){const{x:t,y:n}=this.toAffine();return un(t),un(n),P(n*n)===hi(t)?this:V("bad point: not on curve")}toBytes(t=!0){const{x:n,y:r}=this.assertValidity().toAffine(),o=rt(n);return t?We(b0(r),o):We(En(4),o,rt(r))}toHex(t){return Ir(this.toBytes(t))}}const Xe=new ue(l0,f0,1n),He=new ue(0n,1n,0n);ue.BASE=Xe;ue.ZERO=He;const Sn=e=>Et("0x"+(Ir(e)||"0")),fn=(e,t,n)=>Sn(e.subarray(t,n)),x0=2n**256n,rt=e=>Pr(li(Jt(e,0n,x0),Tt)),Rr=e=>{const t=Sn(Le(e,xe,"secret key"));return Jt(t,1n,nt,"invalid secret key: outside of range")},yi=e=>e>nt>>1n,A0=(e,t=!0)=>Xe.multiply(Rr(e)).toBytes(t),v0=e=>{[0,1,2,3].includes(e)||V("recovery id must be valid and present")},q0=e=>{e!=null&&!ms.includes(e)&&V(`Signature format must be one of: ${ms.join(", ")}`),e===gi&&V('Signature format "der" is not supported: switch to noble-curves')},T0=(e,t=st)=>{q0(t);const n=di.signature,r=n+1;let o=`Signature format "${t}" expects Uint8Array with length `;t===st&&e.length!==n&&V(o+n),t===pn&&e.length!==r&&V(o+r)};let E0=class sr{r;s;recovery;constructor(t,n,r){this.r=nr(t),this.s=nr(n),r!=null&&(this.recovery=r),Object.freeze(this)}static fromBytes(t,n=st){T0(t,n);let r;n===pn&&(r=t[0],t=t.subarray(1));const o=fn(t,0,xe),a=fn(t,xe,Tt);return new sr(o,a,r)}addRecoveryBit(t){return new sr(this.r,this.s,t)}hasHighS(){return yi(this.s)}toBytes(t=st){const{r:n,s:r,recovery:o}=this,a=We(rt(n),rt(r));return t===pn?(v0(o),We(Uint8Array.of(o),a)):a}};const mi=e=>{const t=e.length*8-256;t>1024&&V("msg invalid");const n=Sn(e);return t>0?n>>Et(t):n},S0=e=>bt(mi(Le(e))),st="compact",pn="recovered",gi="der",ms=[st,pn,gi],gs={lowS:!0,prehash:!0,format:st,extraEntropy:!1},bs="SHA-256",Ur={hmacSha256Async:async(e,t)=>{const n=hs(),r="HMAC",o=await n.importKey("raw",e,{name:r,hash:{name:bs}},!1,["sign"]);return Me(await n.sign(r,o,t))},hmacSha256:void 0,sha256Async:async e=>Me(await hs().digest(bs,e)),sha256:void 0},C0=(e,t,n)=>(Le(e,void 0,"message"),t.prehash?n?Ur.sha256Async(e):g0("sha256")(e):e),I0=Me(0),P0=En(0),k0=En(1),R0=1e3,U0="drbg: tried max amount of iterations",B0=async(e,t)=>{let n=Me(xe),r=Me(xe),o=0;const a=()=>{n.fill(1),r.fill(0)},u=(...f)=>Ur.hmacSha256Async(r,We(n,...f)),c=async(f=I0)=>{r=await u(P0,f),n=await u(),f.length!==0&&(r=await u(k0,f),n=await u())},d=async()=>(o++>=R0&&V(U0),n=await u(),n);a(),await c(e);let p;for(;!(p=t(await d()));)await c();return a(),p},$0=(e,t,n,r)=>{let{lowS:o,extraEntropy:a}=n;const u=rt,c=S0(e),d=u(c),p=Rr(t),f=[u(p),d];if(a!=null&&a!==!1){const x=a===!0?pi(xe):a;f.push(Le(x,void 0,"extraEntropy"))}const m=We(...f),y=c;return r(m,x=>{const T=mi(x);if(!(1n<=T&&T<nt))return;const A=kr(T,nt),S=Xe.multiply(T).toAffine(),C=bt(S.x);if(C===0n)return;const I=bt(A*bt(y+C*p));if(I===0n)return;let D=(S.x===C?0:2)|Number(S.y&1n),B=I;return o&&yi(I)&&(B=bt(-I),D^=1),new E0(C,B,D).toBytes(n.format)})},D0=e=>{const t={};return Object.keys(gs).forEach(n=>{t[n]=e[n]??gs[n]}),t},M0=async(e,t,n={})=>(n=D0(n),e=await C0(e,n,!0),$0(e,t,n,B0)),ce={hexToBytes:Pr,bytesToHex:Ir,concatBytes:We,bytesToNumberBE:Sn,numberToBytesBE:rt,mod:P,invert:kr,randomBytes:pi,secretKeyToScalar:Rr,abytes:Le},hn=8,F0=256,bi=Math.ceil(F0/hn)+1,ir=2**(hn-1),O0=()=>{const e=[];let t=Xe,n=t;for(let r=0;r<bi;r++){n=t,e.push(n);for(let o=1;o<ir;o++)n=n.add(t),e.push(n);t=n.double()}return e};let ws;const xs=(e,t)=>{const n=t.negate();return e?n:t},N0=e=>{const t=ws||(ws=O0());let n=He,r=Xe;const o=2**hn,a=o,u=Et(o-1),c=Et(hn);for(let d=0;d<bi;d++){let p=Number(e&u);e>>=c,p>ir&&(p-=a,e+=1n);const f=d*ir,m=f,y=f+Math.abs(p)-1,b=d%2!==0,x=p<0;p===0?r=r.add(xs(b,t[m])):n=n.add(xs(x,t[y]))}return e!==0n&&V("invalid wnaf"),{p:n,f:r}};async function L0(e){const{privateKey:t,domain:n={},types:r,primaryType:o,message:a}=e,u=z0({domain:n,types:r,primaryType:o,message:a}),c=typeof t=="string"?ce.hexToBytes(At(t)):t,d=await M0(u,c,{prehash:!1,format:"recovered"}),p=ce.bytesToHex(d.slice(1,33)),f=ce.bytesToHex(d.slice(33,65)),m=(d[0]+27).toString(16).padStart(2,"0");return`0x${p}${f}${m}`}function z0(e){const{domain:t,types:n,primaryType:r,message:o}=e,a=[];t.name!==void 0&&a.push({name:"name",type:"string"}),t.version!==void 0&&a.push({name:"version",type:"string"}),t.chainId!==void 0&&a.push({name:"chainId",type:"uint256"}),t.verifyingContract!==void 0&&a.push({name:"verifyingContract",type:"address"}),t.salt!==void 0&&a.push({name:"salt",type:"bytes32"});const u={EIP712Domain:a,...n},c=[new Uint8Array([25,1])];return c.push(or("EIP712Domain",t,u)),r!=="EIP712Domain"&&c.push(or(r,o,u)),Ue(ce.concatBytes(...c))}function or(e,t,n){const r=Ue(new TextEncoder().encode(_0(e,n))),o=n[e].map(a=>xi(a.type,t[a.name],n));return Ue(ce.concatBytes(r,...o))}function _0(e,t){const n=wi(e,t);return[e,...n.filter(o=>o!==e).sort()].map(o=>`${o}(${t[o].map(a=>`${H0(a.type)} ${a.name}`).join(",")})`).join("")}function H0(e){return e==="uint"?"uint256":e==="int"?"int256":e}function wi(e,t,n=new Set){if(n.has(e)||!t[e])return[];n.add(e);for(const r of t[e]){const o=r.type.replace(/\[.*?\]/g,"");t[o]&&wi(o,t,n)}return Array.from(n)}function xi(e,t,n){const r=e.match(/^(.*)\[(\d*)\]$/);if(r){const[,a,u]=r;if(!Array.isArray(t))throw new Error(`Expected array for ${e}. Received: ${typeof t}`);if(u&&t.length!==+u)throw new Error(`Invalid length for ${e}: expected ${u}. Received: ${t.length}`);const c=t.map(d=>xi(a,d,n));return Ue(ce.concatBytes(...c))}if(n[e])return t===void 0?new Uint8Array(32):or(e,t,n);if(e==="string")return Ue(new TextEncoder().encode(t));if(e==="address"){const a=ce.hexToBytes(At(t));if(a.length!==20)throw new Error("Address must be 20 bytes.");const u=new Uint8Array(32);return u.set(a,12),u}if(e.startsWith("uint")||e.startsWith("int")){const a=e.startsWith("uint"),u=e.slice(a?4:3),c=parseInt(u||"256");if(c>256||c%8!==0)throw new Error(`Invalid ${a?"uint":"int"} size: ${u}. Must be 8-256 in steps of 8`);const d=BigInt(t),p=a?BigInt.asUintN(c,d):BigInt.asIntN(c,d),f=BigInt.asUintN(256,p).toString(16).padStart(64,"0");return ce.hexToBytes(f)}if(e==="bool"){const a=new Uint8Array(32);return a[31]=t?1:0,a}if(e==="bytes"){const a=typeof t=="string"?ce.hexToBytes(At(t)):t;return Ue(a)}const o=e.match(/^bytes(\d+)$/);if(o){const a=parseInt(o[1]);if(a===0||a>32)throw new Error(`bytesN size must be 1-32. Received: ${a}`);const u=ce.hexToBytes(At(t));if(u.length!==a)throw new Error(`${e} requires exactly ${a} bytes. Received: ${u.length} from '${t}'`);const c=new Uint8Array(32);return c.set(u,0),c}throw new Error(`Unsupported type: '${e}'.`)}function At(e){return e.startsWith("0x")?e.slice(2):e}class V0{#e;address;constructor(t){this.#e=t,this.address=G0(t)}signTypedData(t){return L0({privateKey:this.#e,...t})}}function G0(e){const t=typeof e=="string"?ce.hexToBytes(At(e)):e,n=A0(t,!1);return j0(n)}function j0(e){const t=e.slice(1),r=Ue(t).slice(-20);return`0x${ce.bytesToHex(r)}`}class zn extends vn{response;constructor(t){let n;if(t.status==="err")n=t.response;else if("statuses"in t.response.data){const r=t.response.data.statuses.reduce((o,a,u)=>(typeof a=="object"&&"error"in a&&o.push(`Order ${u}: ${a.error}`),o),[]);r.length>0&&(n=r.join(", "))}else typeof t.response.data.status=="object"&&"error"in t.response.data.status&&(n=t.response.data.status.error);super(n||"An unknown error occurred while processing an API request. See `response` for more details."),this.name="ApiRequestError",this.response=t}}function Br(e){if(e.status==="err")throw new zn(e);if(e.response.type==="order"||e.response.type==="cancel"){if(e.response.data.statuses.some(t=>typeof t=="object"&&"error"in t))throw new zn(e)}else if((e.response.type==="twapOrder"||e.response.type==="twapCancel")&&typeof e.response.data.status=="object"&&"error"in e.response.data.status)throw new zn(e)}let nn=new Map,$r=(e=Symbol(),t=1)=>{if(nn.has(e))return nn.get(e);let n=0,r,o,a=c=>{r?o=o.b={a:c}:o=r={a:c}},u={acquire:()=>++n<=t?Promise.resolve():new Promise(a),release(){r?.a(),r=r?.b,n&&!--n&&nn.delete(e)},size:()=>n};return nn.set(e,u),u};new TextDecoder;function W0(e){let t=0;for(const o of e)t+=o.length;const n=new Uint8Array(t);let r=0;for(const o of e)n.set(o,r),r+=o.length;return n}const As=16,Ai=32,ar=256,wt=65536,xt=4294967296,X0=9223372036854775808n,K0=18446744073709551616n,Y0=new TextEncoder;function Z0(e){const t=[];return cn(e,t),W0(t)}function _n(e){const t=new DataView(new ArrayBuffer(9));return t.setFloat64(1,e),t.setUint8(0,203),new Uint8Array(t.buffer)}function J0(e){if(!Number.isInteger(e))return _n(e);if(e<0){if(e>=-Ai)return new Uint8Array([e]);if(e>=-128)return new Uint8Array([208,e]);if(e>=-32768){const t=new DataView(new ArrayBuffer(3));return t.setInt16(1,e),t.setUint8(0,209),new Uint8Array(t.buffer)}if(e>=-2147483648){const t=new DataView(new ArrayBuffer(5));return t.setInt32(1,e),t.setUint8(0,210),new Uint8Array(t.buffer)}return _n(e)}if(e<=127)return new Uint8Array([e]);if(e<ar)return new Uint8Array([204,e]);if(e<wt){const t=new DataView(new ArrayBuffer(3));return t.setUint16(1,e),t.setUint8(0,205),new Uint8Array(t.buffer)}if(e<xt){const t=new DataView(new ArrayBuffer(5));return t.setUint32(1,e),t.setUint8(0,206),new Uint8Array(t.buffer)}return _n(e)}function cn(e,t){if(e===null){t.push(new Uint8Array([192]));return}if(e===!1){t.push(new Uint8Array([194]));return}if(e===!0){t.push(new Uint8Array([195]));return}if(typeof e=="number"){t.push(J0(e));return}if(typeof e=="bigint"){if(e<0){if(e<-X0)throw new Error("Cannot safely encode bigint larger than 64 bits");const o=new DataView(new ArrayBuffer(9));o.setBigInt64(1,e),o.setUint8(0,211),t.push(new Uint8Array(o.buffer));return}if(e>=K0)throw new Error("Cannot safely encode bigint larger than 64 bits");const r=new DataView(new ArrayBuffer(9));r.setBigUint64(1,e),r.setUint8(0,207),t.push(new Uint8Array(r.buffer));return}if(typeof e=="string"){const r=Y0.encode(e),o=r.length;if(o<Ai)t.push(new Uint8Array([160|o]));else if(o<ar)t.push(new Uint8Array([217,o]));else if(o<wt){const a=new DataView(new ArrayBuffer(3));a.setUint16(1,o),a.setUint8(0,218),t.push(new Uint8Array(a.buffer))}else if(o<xt){const a=new DataView(new ArrayBuffer(5));a.setUint32(1,o),a.setUint8(0,219),t.push(new Uint8Array(a.buffer))}else throw new Error("Cannot safely encode string with size larger than 32 bits");t.push(r);return}if(e instanceof Uint8Array){if(e.length<ar)t.push(new Uint8Array([196,e.length]));else if(e.length<wt){const r=new DataView(new ArrayBuffer(3));r.setUint16(1,e.length),r.setUint8(0,197),t.push(new Uint8Array(r.buffer))}else if(e.length<xt){const r=new DataView(new ArrayBuffer(5));r.setUint32(1,e.length),r.setUint8(0,198),t.push(new Uint8Array(r.buffer))}else throw new Error("Cannot safely encode Uint8Array with size larger than 32 bits");t.push(e);return}if(Array.isArray(e)){if(e.length<As)t.push(new Uint8Array([144|e.length]));else if(e.length<wt){const r=new DataView(new ArrayBuffer(3));r.setUint16(1,e.length),r.setUint8(0,220),t.push(new Uint8Array(r.buffer))}else if(e.length<xt){const r=new DataView(new ArrayBuffer(5));r.setUint32(1,e.length),r.setUint8(0,221),t.push(new Uint8Array(r.buffer))}else throw new Error("Cannot safely encode array with size larger than 32 bits");for(const r of e)cn(r,t);return}const n=Object.getPrototypeOf(e);if(n===null||n===Object.prototype){const r=Object.keys(e).length;if(r<As)t.push(new Uint8Array([128|r]));else if(r<wt){const o=new DataView(new ArrayBuffer(3));o.setUint16(1,r),o.setUint8(0,222),t.push(new Uint8Array(o.buffer))}else if(r<xt){const o=new DataView(new ArrayBuffer(5));o.setUint32(1,r),o.setUint8(0,223),t.push(new Uint8Array(o.buffer))}else throw new Error("Cannot safely encode map with size larger than 32 bits");for(const[o,a]of Object.entries(e))cn(o,t),cn(a,t);return}throw new Error("Cannot safely encode value into messagepack")}const Dr=l({signTypedData:s(pe(),Yt(e=>e.length===3)),getAddress:pe(),provider:de(l({getNetwork:pe()}))}),Mr=l({_signTypedData:s(pe(),Yt(e=>e.length===3)),getAddress:pe(),provider:de(l({getNetwork:pe()}))}),Fr=l({signTypedData:s(pe(),Yt(e=>e.length===1||e.length===2)),getAddresses:pe(),getChainId:pe()}),vi=l({signTypedData:s(pe(),Yt(e=>e.length===1||e.length===2)),address:k()});class we extends vn{constructor(t,n){super(t,n),this.name="AbstractWalletError"}}async function Or(e){const{wallet:t,domain:n,types:r,primaryType:o,message:a}=e;let u;if(fe(Fr,t)||fe(vi,t))try{u=await t.signTypedData({domain:n,types:{EIP712Domain:[{name:"name",type:"string"},{name:"version",type:"string"},{name:"chainId",type:"uint256"},{name:"verifyingContract",type:"address"}],...r},primaryType:o,message:a})}catch(c){throw new we("Failed to sign typed data with viem wallet. See cause for details.",{cause:c})}else if(fe(Dr,t))try{u=await t.signTypedData(n,r,a)}catch(c){throw new we("Failed to sign typed data with ethers v6 wallet. See cause for details.",{cause:c})}else if(fe(Mr,t))try{u=await t._signTypedData(n,r,a)}catch(c){throw new we("Failed to sign typed data with ethers v5 wallet. See cause for details.",{cause:c})}else throw new we("Failed to sign typed data: unknown wallet");return Q0(u)}function Q0(e){const t=`0x${e.slice(2,66)}`,n=`0x${e.slice(66,130)}`,r=parseInt(e.slice(130,132),16);return{r:t,s:n,v:r}}async function vs(e){if(fe(Fr,e))try{return`0x${(await e.getChainId()).toString(16)}`}catch(t){throw new we("Failed to get chain ID from viem wallet. See cause for details.",{cause:t})}if(fe(Dr,e)&&"provider"in e&&e.provider)try{return`0x${(await e.provider.getNetwork()).chainId.toString(16)}`}catch(t){throw new we("Failed to get chain ID from ethers v6 wallet. See cause for details.",{cause:t})}if(fe(Mr,e)&&"provider"in e&&e.provider)try{return`0x${(await e.provider.getNetwork()).chainId.toString(16)}`}catch(t){throw new we("Failed to get chain ID from ethers v5 wallet. See cause for details.",{cause:t})}return"0x1"}async function St(e){if(fe(Fr,e))try{return(await e.getAddresses())[0].toLowerCase()}catch(t){throw new we("Failed to get address from viem wallet. See cause for details.",{cause:t})}if(fe(vi,e))return e.address.toLowerCase();if(fe(Dr,e)||fe(Mr,e))try{return(await e.getAddress()).toLowerCase()}catch(t){throw new we("Failed to get address from ethers wallet. See cause for details.",{cause:t})}throw new we("Failed to get wallet address: unknown wallet")}function qi(e){const{action:t,nonce:n,vaultAddress:r,expiresAfter:o}=e,a=Z0(ur(cr(t))),u=qs(n),c=r?new Uint8Array([1]):new Uint8Array([0]),d=r?Ja(r.slice(2)):new Uint8Array,p=o!==void 0?new Uint8Array([0]):new Uint8Array,f=o!==void 0?qs(o):new Uint8Array,m=Qa(a,u,c,d,p,f),y=Ue(m);return`0x${Za(y)}`}function qs(e){const t=new Uint8Array(8);return new DataView(t.buffer).setBigUint64(0,BigInt(e)),t}function ur(e){if(typeof e=="number"&&Number.isInteger(e)&&(e>=4294967296||e<-2147483648))return BigInt(e);if(Array.isArray(e))return e.map(ur);if(typeof e=="object"&&e!==null){const t={};for(const n in e)t[n]=ur(e[n]);return t}return e}function cr(e){if(Array.isArray(e))return e.map(cr);if(typeof e=="object"&&e!==null){const t={};for(const n in e)e[n]!==void 0&&(t[n]=cr(e[n]));return t}return e}async function Ts(e){const{wallet:t,action:n,nonce:r,isTestnet:o=!1,vaultAddress:a,expiresAfter:u}=e,c=qi({action:n,nonce:r,vaultAddress:a,expiresAfter:u});return await Or({wallet:t,domain:{name:"Exchange",version:"1",chainId:1337,verifyingContract:"0x0000000000000000000000000000000000000000"},types:{Agent:[{name:"source",type:"string"},{name:"connectionId",type:"bytes32"}]},primaryType:"Agent",message:{source:o?"b":"a",connectionId:c}})}async function Es(e){let{wallet:t,action:n,types:r}=e;return n.type==="approveAgent"&&!n.agentName&&(n={...n,agentName:""}),"payloadMultiSigUser"in n&&"outerSigner"in n&&(r=structuredClone(r),Object.values(r)[0].splice(1,0,{name:"payloadMultiSigUser",type:"address"},{name:"outerSigner",type:"address"})),await Or({wallet:t,domain:{name:"HyperliquidSignTransaction",version:"1",chainId:parseInt(n.signatureChainId),verifyingContract:"0x0000000000000000000000000000000000000000"},types:r,primaryType:Object.keys(r)[0],message:n})}async function eu(e){let{wallet:t,action:n,nonce:r,isTestnet:o=!1,vaultAddress:a,expiresAfter:u}=e;"type"in n&&(n=structuredClone(n),delete n.type);const c=qi({action:n,nonce:r,vaultAddress:a,expiresAfter:u}),d={hyperliquidChain:o?"Testnet":"Mainnet",multiSigActionHash:c,nonce:r};return await Or({wallet:t,domain:{name:"HyperliquidSignTransaction",version:"1",chainId:parseInt(n.signatureChainId),verifyingContract:"0x0000000000000000000000000000000000000000"},types:{"HyperliquidTransaction:SendMultiSig":[{name:"hyperliquidChain",type:"string"},{name:"multiSigActionHash",type:"bytes32"},{name:"nonce",type:"uint64"}]},primaryType:"HyperliquidTransaction:SendMultiSig",message:d})}class tu{lastNonce=0;getNonce(){let t=Date.now();return t<=this.lastNonce?t=++this.lastNonce:this.lastNonce=t,t}}const nu=new tu;async function Ti(e,t){const{nonceManager:n}=e;return typeof n=="number"?n:typeof n=="function"?await n(t):nu.getNonce()}async function F(e,t,n){const{transport:r}=e,{action:o,vaultAddress:a,expiresAfter:u}=t,c="signers"in e?await St(e.signers[0]):await St(e.wallet),d=`@nktkas/hyperliquid:${c}:${e.transport.isTestnet}`,p=$r(d);await p.acquire();try{const f=await Ti(e,c);if("signers"in e){const{signers:m,multiSigUser:y}=e,b=c,x=await Promise.all(m.map(async T=>{const A=await Ts({wallet:T,action:[y,b,o],nonce:f,isTestnet:r.isTestnet,vaultAddress:a,expiresAfter:u});return A.r=A.r.replace(/^0x0+/,"0x"),A.s=A.s.replace(/^0x0+/,"0x"),A}));return await Nr({...e,wallet:m[0]},{action:{type:"multiSig",signatureChainId:await Q(e),signatures:x,payload:{multiSigUser:y,outerSigner:b,action:o}},vaultAddress:a,expiresAfter:u,nonce:f},n,!1)}else{const{wallet:m}=e,y=await Ts({wallet:m,action:o,nonce:f,isTestnet:r.isTestnet,vaultAddress:a,expiresAfter:u}),b=await r.request("exchange",{action:o,signature:y,nonce:f,vaultAddress:a,expiresAfter:u},n);return Br(b),b}}finally{p.release()}}async function oe(e,t,n,r){const{transport:o}=e,{action:a}=t,u="signers"in e?await St(e.signers[0]):await St(e.wallet),c=`@nktkas/hyperliquid:${u}:${e.transport.isTestnet}`,d=$r(c);await d.acquire();try{const p=await Ti(e,u);if("time"in a&&(t.action.time=p),"nonce"in a&&(t.action.nonce=p),"signers"in e){const{signers:f,multiSigUser:m}=e,y=u,b=await Promise.all(f.map(async x=>{const T=await Es({wallet:x,action:{payloadMultiSigUser:m,outerSigner:y,...a},types:n});return T.r=T.r.replace(/^0x0+/,"0x"),T.s=T.s.replace(/^0x0+/,"0x"),T}));return await Nr({...e,wallet:f[0]},{action:{type:"multiSig",signatureChainId:a.signatureChainId,signatures:b,payload:{multiSigUser:m,outerSigner:y,action:a}},nonce:p},r,!1)}else{const{wallet:f}=e,m=await Es({wallet:f,action:a,types:n}),y=await o.request("exchange",{action:a,signature:m,nonce:p},r);return Br(y),y}}finally{d.release()}}async function Nr(e,t,n,r=!0){const{transport:o,wallet:a}=e,{action:u,nonce:c,vaultAddress:d,expiresAfter:p}=t;let f;if(r){const y=`@nktkas/hyperliquid:${await St(e.wallet)}:${e.transport.isTestnet}`;f=$r(y),await f.acquire()}try{const m=await eu({wallet:a,action:u,nonce:c,isTestnet:o.isTestnet,vaultAddress:d,expiresAfter:p}),y=await o.request("exchange",{action:u,signature:m,nonce:c,vaultAddress:d,expiresAfter:p},n);return Br(y),y}finally{f?.release()}}async function Q(e){if("signatureChainId"in e&&e.signatureChainId){const t=typeof e.signatureChainId=="string"?e.signatureChainId:await e.signatureChainId();return w(z)(t)}else return"wallet"in e?await vs(e.wallet):await vs(e.signers[0])}const U=s(l({r:s(s(z,ye(66)),i("First 32-byte component of ECDSA signature.")),s:s(s(z,ye(66)),i("Second 32-byte component of ECDSA signature.")),v:s(M([h(27),h(28)]),i("Recovery identifier."))}),i("ECDSA signature components for Ethereum typed data.")),ru=s(l({action:s(l({type:s(h("agentEnableDexAbstraction"),i("Type of action."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Enable HIP-3 DEX abstraction request."));async function su(e,t){const n=w(ru)({action:{type:"agentEnableDexAbstraction"},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,n,t?.signal)}const Ei=s(l({action:s(l({type:s(h("approveAgent"),i("Type of action.")),signatureChainId:s(z,i("Chain ID used for signing.")),hyperliquidChain:s(M([h("Mainnet"),h("Testnet")]),i("HyperLiquid network.")),agentAddress:s(q,i("Agent address.")),agentName:s(E(se(k()),null),i("Agent name or null for unnamed agent.")),nonce:s(g,i("Unique request identifier (current timestamp in ms)."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature."))}),i("Approve an agent to sign on behalf of the master account.")),iu={"HyperliquidTransaction:ApproveAgent":[{name:"hyperliquidChain",type:"string"},{name:"agentAddress",type:"address"},{name:"agentName",type:"string"},{name:"nonce",type:"uint64"}]};async function ou(e,t,n){const r=w(Ei)({action:{type:"approveAgent",hyperliquidChain:e.transport.isTestnet?"Testnet":"Mainnet",signatureChainId:await Q(e),nonce:0,...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27}});return await oe(e,r,iu,n?.signal)}const Si=s(l({action:s(l({type:s(h("approveBuilderFee"),i("Type of action.")),signatureChainId:s(z,i("Chain ID used for signing.")),hyperliquidChain:s(M([h("Mainnet"),h("Testnet")]),i("HyperLiquid network.")),maxFeeRate:s(Zs,i('Max fee rate (e.g., "0.01%").')),builder:s(q,i("Builder address.")),nonce:s(g,i("Unique request identifier (current timestamp in ms)."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature."))}),i("Approve a maximum fee rate for a builder.")),au={"HyperliquidTransaction:ApproveBuilderFee":[{name:"hyperliquidChain",type:"string"},{name:"maxFeeRate",type:"string"},{name:"builder",type:"address"},{name:"nonce",type:"uint64"}]};async function uu(e,t,n){const r=w(Si)({action:{type:"approveBuilderFee",hyperliquidChain:e.transport.isTestnet?"Testnet":"Mainnet",signatureChainId:await Q(e),nonce:0,...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27}});return await oe(e,r,au,n?.signal)}const cu=s(M([h("Gtc"),h("Ioc"),h("Alo"),h("FrontendMarket"),h("LiquidationMarket")]),i('Time-in-force.\n- `"Gtc"`: Remains active until filled or canceled.\n- `"Ioc"`: Fills immediately or cancels any unfilled portion.\n- `"Alo"`: Adds liquidity only.\n- `"FrontendMarket"`: Similar to Ioc, used in Hyperliquid UI.\n- `"LiquidationMarket"`: Similar to Ioc, used in Hyperliquid UI.')),Lr=s(l({a:s(g,i("Asset ID.")),b:s(N(),i("Position side (`true` for long, `false` for short).")),p:s(j,i("Price.")),s:s(j,i("Size (in base currency units).")),r:s(N(),i("Is reduce-only?")),t:s(M([l({limit:s(l({tif:cu}),i("Limit order parameters."))}),l({trigger:s(l({isMarket:s(N(),i("Is market order?")),triggerPx:s(j,i("Trigger price.")),tpsl:s(M([h("tp"),h("sl")]),i("Indicates whether it is take profit or stop loss."))}),i("Trigger order parameters."))})]),i("Order type.")),c:s(E(s(z,ye(34))),i("Client Order ID."))}),i("Place order parameters.")),du=s(M([h("1m"),h("3m"),h("5m"),h("15m"),h("30m"),h("1h"),h("2h"),h("4h"),h("8h"),h("12h"),h("1d"),h("3d"),h("1w"),h("1M")]),i("Time interval.")),Ci=s(l({action:s(l({type:s(h("order"),i("Type of action.")),orders:s(Y(Lr),i("Order parameters.")),grouping:s(E(M([h("na"),h("normalTpsl"),h("positionTpsl")]),"na"),i("Order grouping strategy:\n- `na`: Standard order without grouping.\n- `normalTpsl`: TP/SL order with fixed size that doesn't adjust with position changes.\n- `positionTpsl`: TP/SL order that adjusts proportionally with the position size.")),builder:s(E(l({b:s(q,i("Builder address.")),f:s(g,i("Builder fee in 0.1bps (1 = 0.0001%)."))})),i("Builder fee."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),vaultAddress:s(E(q),i("Vault address (for vault trading).")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Place an order(s)."));async function lu(e,t,n){const r=w(Ci)({action:{type:"order",...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},vaultAddress:n?.vaultAddress??e.defaultVaultAddress,expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,r,n?.signal)}const Ii=s(l({action:s(l({type:s(h("batchModify"),i("Type of action.")),modifies:s(Y(l({oid:s(M([g,s(z,ye(34))]),i("Order ID or Client Order ID.")),order:Lr})),i("Order modifications."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),vaultAddress:s(E(q),i("Vault address (for vault trading).")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Modify multiple orders."));async function fu(e,t,n){const r=w(Ii)({action:{type:"batchModify",...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},vaultAddress:n?.vaultAddress??e.defaultVaultAddress,expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,r,n?.signal)}const Pi=s(l({action:s(l({type:s(h("cancel"),i("Type of action.")),cancels:s(Y(l({a:s(g,i("Asset ID.")),o:s(g,i("Order ID."))})),i("Orders to cancel."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),vaultAddress:s(E(q),i("Vault address (for vault trading).")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Cancel order(s)."));async function pu(e,t,n){const r=w(Pi)({action:{type:"cancel",...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},vaultAddress:n?.vaultAddress??e.defaultVaultAddress,expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,r,n?.signal)}const ki=s(l({action:s(l({type:s(h("cancelByCloid"),i("Type of action.")),cancels:s(Y(l({asset:s(g,i("Asset ID.")),cloid:s(s(z,ye(34)),i("Client Order ID."))})),i("Orders to cancel."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),vaultAddress:s(E(q),i("Vault address (for vault trading).")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Cancel order(s) by cloid."));async function hu(e,t,n){const r=w(ki)({action:{type:"cancelByCloid",...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},vaultAddress:n?.vaultAddress??e.defaultVaultAddress,expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,r,n?.signal)}const Ri=s(l({action:s(l({type:s(h("cDeposit"),i("Type of action.")),signatureChainId:s(z,i("Chain ID used for signing.")),hyperliquidChain:s(M([h("Mainnet"),h("Testnet")]),i("HyperLiquid network.")),wei:s(g,i("Amount of wei to deposit into staking balance (float * 1e8).")),nonce:s(g,i("Unique request identifier (current timestamp in ms)."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature."))}),i("Transfer native token from the user spot account into staking for delegating to validators.")),yu={"HyperliquidTransaction:CDeposit":[{name:"hyperliquidChain",type:"string"},{name:"wei",type:"uint64"},{name:"nonce",type:"uint64"}]};async function mu(e,t,n){const r=w(Ri)({action:{type:"cDeposit",hyperliquidChain:e.transport.isTestnet?"Testnet":"Mainnet",signatureChainId:await Q(e),nonce:0,...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27}});return await oe(e,r,yu,n?.signal)}const Ui=s(l({action:s(l({type:s(h("claimRewards"),i("Type of action."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Claim rewards from referral program."));async function gu(e,t){const n=w(Ui)({action:{type:"claimRewards"},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,n,t?.signal)}const Ss=s(M([l({authorizedUsers:s(Y(q),i("List of authorized user addresses.")),threshold:s(g,i("Minimum number of signatures required."))}),s(vt(),i("Convert a multi-signature account to a single-signature account."))]),i("Signers configuration for `ConvertToMultiSigUserRequest`")),Bi=s(l({action:s(l({type:s(h("convertToMultiSigUser"),i("Type of action.")),signatureChainId:s(z,i("Chain ID used for signing.")),hyperliquidChain:s(M([h("Mainnet"),h("Testnet")]),i("HyperLiquid network.")),signers:s(M([s(k(),Ks(),Ss,er()),s(Ss,er())]),i("Signers configuration.\n\nMust be `ConvertToMultiSigUserRequestSigners` converted to a string via `JSON.stringify(...)`.")),nonce:s(g,i("Unique request identifier (current timestamp in ms)."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature."))}),i("Convert a single-signature account to a multi-signature account or vice versa.")),bu={"HyperliquidTransaction:ConvertToMultiSigUser":[{name:"hyperliquidChain",type:"string"},{name:"signers",type:"string"},{name:"nonce",type:"uint64"}]};async function wu(e,t,n){const r=w(Bi)({action:{type:"convertToMultiSigUser",hyperliquidChain:e.transport.isTestnet?"Testnet":"Mainnet",signatureChainId:await Q(e),nonce:0,...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27}});return await oe(e,r,bu,n?.signal)}const $i=s(l({action:s(l({type:s(h("createSubAccount"),i("Type of action.")),name:s(k(),$e(1),i("Sub-account name."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Create a sub-account."));async function xu(e,t,n){const r=w($i)({action:{type:"createSubAccount",...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,r,n?.signal)}const Di=s(l({action:s(l({type:s(h("createVault"),i("Type of action.")),name:s(k(),$e(3),i("Vault name.")),description:s(k(),$e(10),i("Vault description.")),initialUsd:s(g,qn(1e8),i("Initial balance (float * 1e6).")),nonce:s(E(g,()=>Date.now()),i("Unique request identifier (current timestamp in ms)."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Create a vault."));async function Au(e,t,n){const r=w(Di)({action:{type:"createVault",...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,r,n?.signal)}const Mi=s(l({action:s(M([l({type:s(h("CSignerAction"),i("Type of action.")),jailSelf:s(vt(),i("Jail the signer."))}),l({type:s(h("CSignerAction"),i("Type of action.")),unjailSelf:s(vt(),i("Unjail the signer."))})]),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Jail or unjail self as a validator signer."));async function vu(e,t,n){const r=w(Mi)({action:{type:"CSignerAction",...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,r,n?.signal)}const Fi=s(l({action:s(M([l({type:s(h("CValidatorAction"),i("Type of action.")),changeProfile:s(l({node_ip:s(se(l({Ip:s(k(),Qn(),i("IP address."))})),i("Validator node IP address.")),name:s(se(k()),i("Validator name.")),description:s(se(k()),i("Validator description.")),unjailed:s(N(),i("Validator jail status.")),disable_delegations:s(se(N()),i("Enable or disable delegations.")),commission_bps:s(se(g),i("Commission rate in basis points (1 = 0.0001%).")),signer:s(se(q),i("Signer address."))}),i("Profile changes to apply."))}),l({type:s(h("CValidatorAction"),i("Type of action.")),register:s(l({profile:s(l({node_ip:s(l({Ip:s(k(),Qn(),i("IP address."))}),i("Validator node IP address.")),name:s(k(),i("Validator name.")),description:s(k(),i("Validator description.")),delegations_disabled:s(N(),i("Whether delegations are disabled.")),commission_bps:s(g,i("Commission rate in basis points (1 = 0.0001%).")),signer:s(q,i("Signer address."))}),i("Validator profile information.")),unjailed:s(N(),i("Initial jail status.")),initial_wei:s(g,i("Initial stake amount in wei."))}),i("Registration parameters."))}),l({type:s(h("CValidatorAction"),i("Type of action.")),unregister:s(vt(),i("Unregister the validator."))})]),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Action related to validator management."));async function qu(e,t,n){const r=w(Fi)({action:{type:"CValidatorAction",...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,r,n?.signal)}const Oi=s(l({action:s(l({type:s(h("cWithdraw"),i("Type of action.")),signatureChainId:s(z,i("Chain ID used for signing.")),hyperliquidChain:s(M([h("Mainnet"),h("Testnet")]),i("HyperLiquid network.")),wei:s(g,i("Amount of wei to withdraw from staking balance (float * 1e8).")),nonce:s(g,i("Unique request identifier (current timestamp in ms)."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature."))}),i("Transfer native token from staking into the user's spot account.")),Tu={"HyperliquidTransaction:CWithdraw":[{name:"hyperliquidChain",type:"string"},{name:"wei",type:"uint64"},{name:"nonce",type:"uint64"}]};async function Eu(e,t,n){const r=w(Oi)({action:{type:"cWithdraw",hyperliquidChain:e.transport.isTestnet?"Testnet":"Mainnet",signatureChainId:await Q(e),nonce:0,...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27}});return await oe(e,r,Tu,n?.signal)}const Ni=s(l({action:s(l({type:s(h("evmUserModify"),i("Type of action.")),usingBigBlocks:s(N(),i("`true` for large blocks, `false` for small blocks."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Configure block type for EVM transactions."));async function Su(e,t,n){const r=w(Ni)({action:{type:"evmUserModify",...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,r,n?.signal)}const Cu=s(l({action:s(l({type:s(h("linkStakingUser"),i("Type of action.")),signatureChainId:s(z,i("Chain ID used for signing.")),hyperliquidChain:s(M([h("Mainnet"),h("Testnet")]),i("HyperLiquid network.")),user:s(q,i(`Target account address.
- Trading user initiating: enter staking account address.
- Staking user finalizing: enter trading account address.`)),isFinalize:s(N(),i("Link phase.\n- `false` = trading user initiates link request.\n- `true` = staking user finalizes permanent link.")),nonce:s(g,i("Unique request identifier (current timestamp in ms)."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature."))}),i("")),Iu={"HyperliquidTransaction:LinkStakingUser":[{name:"hyperliquidChain",type:"string"},{name:"user",type:"address"},{name:"isFinalize",type:"bool"},{name:"nonce",type:"uint64"}]};async function Pu(e,t,n){const r=w(Cu)({action:{type:"linkStakingUser",hyperliquidChain:e.transport.isTestnet?"Testnet":"Mainnet",signatureChainId:await Q(e),nonce:0,...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27}});return await oe(e,r,Iu,n?.signal)}const Li=s(l({action:s(l({type:s(h("modify"),i("Type of action.")),oid:s(M([g,s(z,ye(34))]),i("Order ID or Client Order ID.")),order:Lr}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),vaultAddress:s(E(q),i("Vault address (for vault trading).")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Modify an order."));async function ku(e,t,n){const r=w(Li)({action:{type:"modify",...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},vaultAddress:n?.vaultAddress??e.defaultVaultAddress,expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,r,n?.signal)}const zi=s(l({action:s(l({type:s(h("noop"),i("Type of action."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("This action does not do anything (no operation), but causes the nonce to be marked as used."));async function Ru(e,t){const n=w(zi)({action:{type:"noop"},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,n,t?.signal)}const _i=s(l({action:s(l({type:s(h("registerReferrer"),i("Type of action.")),code:s(k(),$e(1),i("Referral code to create."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Create a referral code."));async function Uu(e,t,n){const r=w(_i)({action:{type:"registerReferrer",...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,r,n?.signal)}const Hi=s(l({action:s(l({type:s(h("reserveRequestWeight"),i("Type of action.")),weight:s(g,i("Amount of request weight to reserve."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Reserve additional rate-limited actions for a fee."));async function Bu(e,t,n){const r=w(Hi)({action:{type:"reserveRequestWeight",...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,r,n?.signal)}const Vi=s(l({action:s(l({type:s(h("scheduleCancel"),i("Type of action.")),time:s(E(g),i(`Scheduled time (in ms since epoch).
Must be at least 5 seconds in the future.

If not specified, will cause all scheduled cancel operations to be deleted.`))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),vaultAddress:s(E(q),i("Vault address (for vault trading).")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Schedule a cancel-all operation at a future time."));async function $u(e,t,n){const r=t&&"time"in t,o=r?t:{},a=r?n:t,u=w(Vi)({action:{type:"scheduleCancel",...o},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},vaultAddress:a?.vaultAddress??e.defaultVaultAddress,expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,u,a?.signal)}const Gi=s(l({action:s(l({type:s(h("setDisplayName"),i("Type of action.")),displayName:s(k(),i(`Display name.

Set to an empty string to remove the display name.`))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Set the display name in the leaderboard."));async function Du(e,t,n){const r=w(Gi)({action:{type:"setDisplayName",...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,r,n?.signal)}const ji=s(l({action:s(l({type:s(h("setReferrer"),i("Type of action.")),code:s(k(),$e(1),i("Referral code."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Set a referral code."));async function Mu(e,t,n){const r=w(ji)({action:{type:"setReferrer",...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,r,n?.signal)}const Wi=s(l({action:s(M([s(l({type:s(h("spotDeploy"),i("Type of action.")),genesis:s(l({token:s(g,i("Token identifier.")),maxSupply:s(j,i("Maximum token supply.")),noHyperliquidity:s(E(h(!0)),i("Set hyperliquidity balance to 0."))}),i("Genesis parameters."))}),i("Genesis variant")),s(l({type:s(h("spotDeploy"),i("Type of action.")),registerHyperliquidity:s(l({spot:s(g,i("Spot index (distinct from base token index).")),startPx:s(j,i("Starting price for liquidity seeding.")),orderSz:s(j,i("Order size as a float (not in wei).")),nOrders:s(g,i("Total number of orders to place.")),nSeededLevels:s(E(g),i("Number of levels to seed with USDC."))}),i("Register hyperliquidity parameters."))}),i("Register hyperliquidity variant")),s(l({type:s(h("spotDeploy"),i("Type of action.")),registerSpot:s(l({tokens:s(le([g,g]),i("Tuple containing base and quote token indices."))}),i("Register spot parameters."))}),i("Register spot variant")),s(l({type:s(h("spotDeploy"),i("Type of action.")),registerToken2:s(l({spec:s(l({name:s(k(),i("Token name.")),szDecimals:s(g,i("Number of decimals for token size.")),weiDecimals:s(g,i("Number of decimals for token amounts in wei."))}),i("Token specifications.")),maxGas:s(g,i("Maximum gas allowed for registration.")),fullName:s(E(k()),i("Optional full token name."))}),i("Register token parameters."))}),i("Register token variant")),s(l({type:s(h("spotDeploy"),i("Type of action.")),setDeployerTradingFeeShare:s(l({token:s(g,i("Token identifier.")),share:s(Zs,i("The deployer trading fee share. Range is 0% to 100%."))}),i("Set deployer trading fee share parameters."))}),i("Set deployer trading fee share variant")),s(l({type:s(h("spotDeploy"),i("Type of action.")),userGenesis:s(l({token:s(g,i("Token identifier.")),userAndWei:s(Y(le([q,j])),i("Array of tuples: [user address, genesis amount in wei].")),existingTokenAndWei:s(Y(le([g,j])),i("Array of tuples: [existing token identifier, genesis amount in wei].")),blacklistUsers:s(E(Y(le([q,N()]))),i("Array of tuples: [user address, blacklist status] (`true` for blacklist, `false` to remove existing blacklisted user)."))}),i("User genesis parameters."))}),i("User genesis variant")),s(l({type:s(h("spotDeploy"),i("Type of action.")),enableQuoteToken:s(l({token:s(g,i("The token ID to convert to a quote token."))}),i("Enable quote token parameters."))}),i("Convert token to quote token variant"))]),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i(`Deploying HIP-1 and HIP-2 assets:
- Genesis
- Register Hyperliquidity
- Register Spot
- Register Token2
- Set Deployer Trading Fee Share
- User Genesis`));async function Fu(e,t,n){const r=w(Wi)({action:{type:"spotDeploy",...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,r,n?.signal)}const Xi=s(l({action:s(l({type:s(h("subAccountModify"),i("Type of action.")),subAccountUser:s(q,i("Sub-account address to modify.")),name:s(k(),$e(1),i("New sub-account name."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Modify a sub-account."));async function Ou(e,t,n){const r=w(Xi)({action:{type:"subAccountModify",...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,r,n?.signal)}const Ki=s(l({action:s(l({type:s(h("tokenDelegate"),i("Type of action.")),signatureChainId:s(z,i("Chain ID used for signing.")),hyperliquidChain:s(M([h("Mainnet"),h("Testnet")]),i("HyperLiquid network.")),validator:s(q,i("Validator address.")),wei:s(g,i("Amount for delegate/undelegate (float * 1e8).")),isUndelegate:s(N(),i("`true` for undelegate, `false` for delegate.")),nonce:s(g,i("Unique request identifier (current timestamp in ms)."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature."))}),i("Delegate or undelegate native tokens to or from a validator.")),Nu={"HyperliquidTransaction:TokenDelegate":[{name:"hyperliquidChain",type:"string"},{name:"validator",type:"address"},{name:"wei",type:"uint64"},{name:"isUndelegate",type:"bool"},{name:"nonce",type:"uint64"}]};async function Lu(e,t,n){const r=w(Ki)({action:{type:"tokenDelegate",hyperliquidChain:e.transport.isTestnet?"Testnet":"Mainnet",signatureChainId:await Q(e),nonce:0,...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27}});return await oe(e,r,Nu,n?.signal)}const Yi=s(l({action:s(l({type:s(h("twapOrder"),i("Type of action.")),twap:s(l({a:s(g,i("Asset ID.")),b:s(N(),i("Position side (`true` for long, `false` for short).")),s:s(j,i("Size (in base currency units).")),r:s(N(),i("Is reduce-only?")),m:s(g,i("TWAP duration in minutes.")),t:s(N(),i("Enable random order timing."))}),i("Twap parameters."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),vaultAddress:s(E(q),i("Vault address (for vault trading).")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Place a TWAP order."));async function zu(e,t,n){const r=w(Yi)({action:{type:"twapOrder",...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},vaultAddress:n?.vaultAddress??e.defaultVaultAddress,expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,r,n?.signal)}const Zi=s(l({action:s(l({type:s(h("usdClassTransfer"),i("Type of action.")),signatureChainId:s(z,i("Chain ID used for signing.")),hyperliquidChain:s(M([h("Mainnet"),h("Testnet")]),i("HyperLiquid network.")),amount:s(j,i("Amount to transfer (1 = $1).")),toPerp:s(N(),i("`true` for Spot to Perp, `false` for Perp to Spot.")),nonce:s(g,i("Unique request identifier (current timestamp in ms)."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature."))}),i("Transfer funds between Spot account and Perp account.")),_u={"HyperliquidTransaction:UsdClassTransfer":[{name:"hyperliquidChain",type:"string"},{name:"amount",type:"string"},{name:"toPerp",type:"bool"},{name:"nonce",type:"uint64"}]};async function Hu(e,t,n){const r=w(Zi)({action:{type:"usdClassTransfer",hyperliquidChain:e.transport.isTestnet?"Testnet":"Mainnet",signatureChainId:await Q(e),nonce:0,...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27}});return await oe(e,r,_u,n?.signal)}const Ji=s(l({action:s(l({type:s(h("vaultDistribute"),i("Type of action.")),vaultAddress:s(q,i("Vault address.")),usd:s(g,i(`Amount to distribute (float * 1e6).

Set to 0 to close the vault.`))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Distribute funds from a vault between followers."));async function Vu(e,t,n){const r=w(Ji)({action:{type:"vaultDistribute",...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,r,n?.signal)}const Qi=s(l({action:s(l({type:s(h("withdraw3"),i("Type of action.")),signatureChainId:s(z,i("Chain ID used for signing.")),hyperliquidChain:s(M([h("Mainnet"),h("Testnet")]),i("HyperLiquid network.")),destination:s(q,i("Destination address.")),amount:s(j,i("Amount to withdraw (1 = $1).")),time:s(g,i("Unique request identifier (current timestamp in ms)."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature."))}),i("Initiate a withdrawal request.")),Gu={"HyperliquidTransaction:Withdraw":[{name:"hyperliquidChain",type:"string"},{name:"destination",type:"string"},{name:"amount",type:"string"},{name:"time",type:"uint64"}]};async function ju(e,t,n){const r=w(Qi)({action:{type:"withdraw3",hyperliquidChain:e.transport.isTestnet?"Testnet":"Mainnet",signatureChainId:await Q(e),time:0,...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27}});return await oe(e,r,Gu,n?.signal)}const eo=s(l({action:s(M([l({type:s(h("perpDeploy"),i("Type of action.")),registerAsset:s(l({maxGas:s(se(g),i("Max gas in native token wei. If not provided, then uses current deploy auction price.")),assetRequest:s(l({coin:s(k(),i("Coin symbol for the new asset.")),szDecimals:s(g,i("Number of decimal places for size.")),oraclePx:s(j,i("Initial oracle price for the asset.")),marginTableId:s(g,i("Margin table identifier for risk management.")),onlyIsolated:s(N(),i("Whether the asset can only be traded with isolated margin."))}),i("Contains new asset listing parameters.")),dex:s(k(),i("Name of the dex.")),schema:s(se(l({fullName:s(k(),i("Full name of the dex.")),collateralToken:s(g,i("Collateral token index.")),oracleUpdater:s(se(q),i("User to update oracles. If not provided, then deployer is assumed to be oracle updater."))})),i("Contains new dex parameters."))}),i("Parameters for registering a new perpetual asset."))}),l({type:s(h("perpDeploy"),i("Type of action.")),setOracle:s(l({dex:s(k(),$e(1),i("Name of the dex.")),oraclePxs:s(Y(le([k(),j])),i("A list (sorted by key) of asset and oracle prices.")),markPxs:s(Y(Y(le([k(),j]))),i("An outer list of inner lists (inner list sorted by key) of asset and mark prices.")),externalPerpPxs:s(Y(le([k(),j])),i("A list (sorted by key) of asset and external prices which prevent sudden mark price deviations."))}),i("Parameters for setting oracle and mark prices for assets."))}),l({type:s(h("perpDeploy"),i("Type of action.")),setFundingMultipliers:s(Y(le([k(),j])),i("A list (sorted by key) of asset and funding multiplier."))}),l({type:s(h("perpDeploy"),i("Type of action.")),haltTrading:s(l({coin:s(k(),i("Coin symbol for the asset to halt or resume.")),isHalted:s(N(),i("Whether trading should be halted (true) or resumed (false)."))}),i("Parameters for halting or resuming trading for an asset."))}),l({type:s(h("perpDeploy"),i("Type of action.")),setMarginTableIds:s(Y(le([k(),g])),i("A list (sorted by key) of asset and margin table ids."))}),l({type:s(h("perpDeploy"),i("Type of action.")),setFeeRecipient:s(l({dex:s(k(),i("Name of the DEX.")),feeRecipient:s(q,i("Address of the fee recipient."))}),i("Parameters for setting the fee recipient."))}),l({type:s(h("perpDeploy"),i("Type of action.")),setOpenInterestCaps:s(Y(le([k(),g])),i("A list (sorted by key) of asset and open interest cap notionals."))}),l({type:s(h("perpDeploy"),i("Type of action.")),setSubDeployers:s(l({dex:s(k(),i("Name of the DEX.")),subDeployers:s(Y(l({variant:s(k(),i("Corresponds to a variant of PerpDeployAction.")),user:s(q,i("Sub-deployer address.")),allowed:s(N(),i("Add or remove the subDeployer from the authorized set for the action variant."))})),i("A modification to sub-deployer permissions."))}),i("A modification to sub-deployer permissions."))}),l({type:s(h("perpDeploy"),i("Type of action.")),setFeeScale:s(l({dex:s(k(),i("Name of the dex.")),scale:s(j,i("Fee scale (between 0.0 and 3.0)."))}),i("Set fee scale."))})]),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Deploying HIP-3 assets."));async function Wu(e,t,n){const r=w(eo)({action:{type:"perpDeploy",...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,r,n?.signal)}const to=s(l({action:s(l({type:s(h("sendAsset"),i("Type of action.")),signatureChainId:s(z,i("Chain ID used for signing.")),hyperliquidChain:s(M([h("Mainnet"),h("Testnet")]),i("HyperLiquid network.")),destination:s(q,i("Destination address.")),sourceDex:s(k(),i('Source DEX ("" for default USDC perp DEX, "spot" for spot).')),destinationDex:s(k(),i('Destination DEX ("" for default USDC perp DEX, "spot" for spot).')),token:s(Cr,i("Token identifier.")),amount:s(j,i("Amount to send (not in wei).")),fromSubAccount:s(E(M([h(""),q]),""),i('Source sub-account address ("" for main account).')),nonce:s(g,i("Unique request identifier (current timestamp in ms)."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature."))}),i("Transfer tokens between different perp DEXs, spot balance, users, and/or sub-accounts.")),Xu={"HyperliquidTransaction:SendAsset":[{name:"hyperliquidChain",type:"string"},{name:"destination",type:"string"},{name:"sourceDex",type:"string"},{name:"destinationDex",type:"string"},{name:"token",type:"string"},{name:"amount",type:"string"},{name:"fromSubAccount",type:"string"},{name:"nonce",type:"uint64"}]};async function Ku(e,t,n){const r=w(to)({action:{type:"sendAsset",hyperliquidChain:e.transport.isTestnet?"Testnet":"Mainnet",signatureChainId:await Q(e),nonce:0,...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27}});return await oe(e,r,Xu,n?.signal)}const no=s(l({action:s(l({type:s(h("spotSend"),i("Type of action.")),signatureChainId:s(z,i("Chain ID used for signing.")),hyperliquidChain:s(M([h("Mainnet"),h("Testnet")]),i("HyperLiquid network.")),destination:s(q,i("Destination address.")),token:s(Cr,i("Token identifier.")),amount:s(j,i("Amount to send (not in wei).")),time:s(g,i("Unique request identifier (current timestamp in ms)."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature."))}),i("Send spot assets to another address.")),Yu={"HyperliquidTransaction:SpotSend":[{name:"hyperliquidChain",type:"string"},{name:"destination",type:"string"},{name:"token",type:"string"},{name:"amount",type:"string"},{name:"time",type:"uint64"}]};async function Zu(e,t,n){const r=w(no)({action:{type:"spotSend",hyperliquidChain:e.transport.isTestnet?"Testnet":"Mainnet",signatureChainId:await Q(e),time:0,...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27}});return await oe(e,r,Yu,n?.signal)}const ro=s(l({action:s(l({type:s(h("spotUser"),i("Type of action.")),toggleSpotDusting:s(l({optOut:s(N(),i("Opt out of spot dusting."))}),i("Spot dusting options."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Opt Out of Spot Dusting."));async function Ju(e,t,n){const r=w(ro)({action:{type:"spotUser",...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,r,n?.signal)}const so=s(l({action:s(l({type:s(h("subAccountSpotTransfer"),i("Type of action.")),subAccountUser:s(q,i("Sub-account address.")),isDeposit:s(N(),i("`true` for deposit, `false` for withdrawal.")),token:s(Cr,i("Token identifier.")),amount:s(j,i("Amount to send (not in wei)."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Transfer between sub-accounts (spot)."));async function Qu(e,t,n){const r=w(so)({action:{type:"subAccountSpotTransfer",...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,r,n?.signal)}const io=s(l({action:s(l({type:s(h("subAccountTransfer"),i("Type of action.")),subAccountUser:s(q,i("Sub-account address.")),isDeposit:s(N(),i("`true` for deposit, `false` for withdrawal.")),usd:s(g,i("Amount to transfer (float * 1e6)."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Transfer between sub-accounts (perpetual)."));async function ec(e,t,n){const r=w(io)({action:{type:"subAccountTransfer",...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,r,n?.signal)}const oo=s(l({action:s(l({type:s(h("twapCancel"),i("Type of action.")),a:s(g,i("Asset ID.")),t:s(g,i("Twap ID."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),vaultAddress:s(E(q),i("Vault address (for vault trading).")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Cancel a TWAP order."));async function tc(e,t,n){const r=w(oo)({action:{type:"twapCancel",...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},vaultAddress:n?.vaultAddress??e.defaultVaultAddress,expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,r,n?.signal)}const ao=s(l({action:s(l({type:s(h("updateIsolatedMargin"),i("Type of action.")),asset:s(g,i("Asset ID.")),isBuy:s(N(),i("Position side (`true` for long, `false` for short).")),ntli:s(tr,i("Amount to adjust (float * 1e6)."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),vaultAddress:s(E(q),i("Vault address (for vault trading).")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Add or remove margin from isolated position."));async function nc(e,t,n){const r=w(ao)({action:{type:"updateIsolatedMargin",...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},vaultAddress:n?.vaultAddress??e.defaultVaultAddress,expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,r,n?.signal)}const uo=s(l({action:s(l({type:s(h("updateLeverage"),i("Type of action.")),asset:s(g,i("Asset ID.")),isCross:s(N(),i("`true` for cross leverage, `false` for isolated leverage.")),leverage:s(s(g,qn(1)),i("New leverage value."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),vaultAddress:s(E(q),i("Vault address (for vault trading).")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Update cross or isolated leverage on a coin."));async function rc(e,t,n){const r=w(uo)({action:{type:"updateLeverage",...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},vaultAddress:n?.vaultAddress??e.defaultVaultAddress,expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,r,n?.signal)}const co=s(l({action:s(l({type:s(h("usdSend"),i("Type of action.")),signatureChainId:s(z,i("Chain ID used for signing.")),hyperliquidChain:s(M([h("Mainnet"),h("Testnet")]),i("HyperLiquid network.")),destination:s(q,i("Destination address.")),amount:s(j,i("Amount to send (1 = $1).")),time:s(g,i("Unique request identifier (current timestamp in ms)."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature."))}),i("Send usd to another address.")),sc={"HyperliquidTransaction:UsdSend":[{name:"hyperliquidChain",type:"string"},{name:"destination",type:"string"},{name:"amount",type:"string"},{name:"time",type:"uint64"}]};async function ic(e,t,n){const r=w(co)({action:{type:"usdSend",hyperliquidChain:e.transport.isTestnet?"Testnet":"Mainnet",signatureChainId:await Q(e),time:0,...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27}});return await oe(e,r,sc,n?.signal)}const lo=s(l({action:s(l({type:s(h("vaultModify"),i("Type of action.")),vaultAddress:s(q,i("Vault address.")),allowDeposits:s(E(se(N()),null),i("Allow deposits from followers.")),alwaysCloseOnWithdraw:s(E(se(N()),null),i("Always close positions on withdrawal."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Modify a vault's configuration."));async function oc(e,t,n){const r=w(lo)({action:{type:"vaultModify",...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,r,n?.signal)}const fo=s(l({action:s(l({type:s(h("vaultTransfer"),i("Type of action.")),vaultAddress:s(q,i("Vault address.")),isDeposit:s(N(),i("`true` for deposit, `false` for withdrawal.")),usd:s(g,i("Amount for deposit/withdrawal (float * 1e6)."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Deposit or withdraw from a vault."));async function ac(e,t,n){const r=w(fo)({action:{type:"vaultTransfer",...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,r,n?.signal)}const uc=s(l({action:s(l({type:s(h("multiSig"),i("Type of action.")),signatureChainId:s(z,i("Chain ID used for signing.")),signatures:s(Y(U),i("List of signatures from authorized signers.")),payload:s(l({multiSigUser:s(q,i("Address of the multi-signature user account.")),outerSigner:s(q,i("Address of the authorized user initiating the request (any authorized user).")),action:s(M([Ei.entries.action,Si.entries.action,Ii.entries.action,Pi.entries.action,ki.entries.action,Ri.entries.action,Ui.entries.action,Bi.entries.action,$i.entries.action,Di.entries.action,Mi.entries.action,Fi.entries.action,Oi.entries.action,Ni.entries.action,Li.entries.action,zi.entries.action,Ci.entries.action,eo.entries.action,_i.entries.action,Hi.entries.action,Vi.entries.action,to.entries.action,Gi.entries.action,ji.entries.action,Wi.entries.action,no.entries.action,ro.entries.action,Xi.entries.action,so.entries.action,io.entries.action,Ki.entries.action,oo.entries.action,Yi.entries.action,ao.entries.action,uo.entries.action,Zi.entries.action,co.entries.action,Ji.entries.action,lo.entries.action,fo.entries.action,Qi.entries.action]),i("The underlying action to be executed through multi-sig."))}),i("Multi-signature payload information."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),vaultAddress:s(E(q),i("Vault address (for vault trading).")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("A multi-signature request."));async function cc(e,t,n){const{nonce:r,...o}=t,a=w(uc)({action:{type:"multiSig",signatureChainId:await Q(e),...o},nonce:r,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},vaultAddress:n?.vaultAddress??e.defaultVaultAddress,expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await Nr(e,a,n?.signal)}const dc=s(l({action:s(l({type:s(h("userDexAbstraction"),i("Type of action.")),signatureChainId:s(z,i("Chain ID used for signing.")),hyperliquidChain:s(M([h("Mainnet"),h("Testnet")]),i("HyperLiquid network.")),user:s(q,i("User address.")),enabled:s(N(),i("Whether to enable or disable HIP-3 DEX abstraction.")),nonce:s(g,i("Unique request identifier (current timestamp in ms)."))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature."))}),i("Enable/disable HIP-3 DEX abstraction.")),lc={"HyperliquidTransaction:UserDexAbstraction":[{name:"hyperliquidChain",type:"string"},{name:"user",type:"address"},{name:"enabled",type:"bool"},{name:"nonce",type:"uint64"}]};async function fc(e,t,n){const r=w(dc)({action:{type:"userDexAbstraction",hyperliquidChain:e.transport.isTestnet?"Testnet":"Mainnet",signatureChainId:await Q(e),nonce:0,...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27}});return await oe(e,r,lc,n?.signal)}const pc=s(l({action:s(l({type:s(h("validatorL1Stream"),i("Type of action.")),riskFreeRate:s(j,i('Risk-free rate as a decimal string (e.g., "0.05" for 5%).'))}),i("Action to perform.")),nonce:s(g,i("Unique request identifier (current timestamp in ms).")),signature:s(U,i("Cryptographic signature.")),expiresAfter:s(E(g),i("Expiration time of the action."))}),i("Validator vote on risk-free rate for aligned quote asset."));async function hc(e,t,n){const r=w(pc)({action:{type:"validatorL1Stream",...t},nonce:0,signature:{r:"0x0000000000000000000000000000000000000000000000000000000000000000",s:"0x0000000000000000000000000000000000000000000000000000000000000000",v:27},expiresAfter:typeof e.defaultExpiresAfter=="number"?e.defaultExpiresAfter:await e.defaultExpiresAfter?.()});return await F(e,r,n?.signal)}class yc{transport;wallet;signatureChainId;defaultVaultAddress;defaultExpiresAfter;nonceManager;constructor(t){this.transport=t.transport,this.wallet=typeof t.wallet=="string"?new V0(t.wallet):t.wallet,this.defaultVaultAddress=t.defaultVaultAddress,this.defaultExpiresAfter=t.defaultExpiresAfter,this.signatureChainId=t.signatureChainId,this.nonceManager=t.nonceManager}agentEnableDexAbstraction(...t){return su(this,...t)}approveAgent(...t){return ou(this,...t)}approveBuilderFee(...t){return uu(this,...t)}batchModify(...t){return fu(this,...t)}cancel(...t){return pu(this,...t)}cancelByCloid(...t){return hu(this,...t)}cDeposit(...t){return mu(this,...t)}claimRewards(...t){return gu(this,...t)}convertToMultiSigUser(...t){return wu(this,...t)}createSubAccount(...t){return xu(this,...t)}createVault(...t){return Au(this,...t)}cSignerAction(...t){return vu(this,...t)}cValidatorAction(...t){return qu(this,...t)}cWithdraw(...t){return Eu(this,...t)}evmUserModify(...t){return Su(this,...t)}linkStakingUser(...t){return Pu(this,...t)}modify(...t){return ku(this,...t)}multiSig(...t){return cc(this,...t)}order(...t){return lu(this,...t)}noop(...t){return Ru(this,...t)}perpDeploy(...t){return Wu(this,...t)}registerReferrer(...t){return Uu(this,...t)}reserveRequestWeight(...t){return Bu(this,...t)}scheduleCancel(...t){return $u(this,...t)}sendAsset(...t){return Ku(this,...t)}setDisplayName(...t){return Du(this,...t)}setReferrer(...t){return Mu(this,...t)}spotDeploy(...t){return Fu(this,...t)}spotSend(...t){return Zu(this,...t)}spotUser(...t){return Ju(this,...t)}subAccountModify(...t){return Ou(this,...t)}subAccountSpotTransfer(...t){return Qu(this,...t)}subAccountTransfer(...t){return ec(this,...t)}tokenDelegate(...t){return Lu(this,...t)}twapCancel(...t){return tc(this,...t)}twapOrder(...t){return zu(this,...t)}updateIsolatedMargin(...t){return nc(this,...t)}updateLeverage(...t){return rc(this,...t)}usdClassTransfer(...t){return Hu(this,...t)}usdSend(...t){return ic(this,...t)}userDexAbstraction(...t){return fc(this,...t)}validatorL1Stream(...t){return hc(this,...t)}vaultDistribute(...t){return Vu(this,...t)}vaultModify(...t){return oc(this,...t)}vaultTransfer(...t){return ac(this,...t)}withdraw3(...t){return ju(this,...t)}}const mc=s(l({type:s(h("activeAssetData"),i("Type of request.")),coin:s(k(),i("Asset symbol (e.g., BTC).")),user:s(q,i("User address."))}),i("Request user active asset data."));function gc(e,t,n){const r=w(mc)({type:"activeAssetData",...t});return e.transport.request("info",r,n)}const bc=s(l({type:s(h("alignedQuoteTokenInfo"),i("Type of request.")),token:s(g,i("Token index."))}),i("Request supply, rate, and pending payment information for an aligned quote token."));function wc(e,t,n){const r=w(bc)({type:"alignedQuoteTokenInfo",...t});return e.transport.request("info",r,n)}const xc=s(l({type:s(h("allMids"),i("Type of request.")),dex:s(E(k()),i("DEX name (empty string for main dex)."))}),i("Request mid coin prices."));function Ac(e,t,n){const r=t instanceof AbortSignal?{}:t,o=t instanceof AbortSignal?t:n,a=w(xc)({type:"allMids",...r});return e.transport.request("info",a,o)}const vc=s(l({type:s(h("marginTable"),i("Type of request.")),id:s(g,i("Margin requirements table."))}),i("Request margin table data."));function qc(e,t,n){const r=w(vc)({type:"marginTable",...t});return e.transport.request("info",r,n)}const Tc=s(l({type:s(h("meta"),i("Type of request.")),dex:s(E(k()),i("DEX name (empty string for main dex)."))}),i("Request trading metadata."));function Ec(e,t,n){const r=t instanceof AbortSignal?{}:t,o=t instanceof AbortSignal?t:n,a=w(Tc)({type:"meta",...r});return e.transport.request("info",a,o)}const Sc=s(l({type:s(h("allPerpMetas"),i("Type of request."))}),i("Request trading metadata for all DEXes."));function Cc(e,t){const n=w(Sc)({type:"allPerpMetas"});return e.transport.request("info",n,t)}const Ic=s(l({type:s(h("blockDetails"),i("Type of request.")),height:s(g,i("Block height."))}),i("Request block details by block height."));function Pc(e,t,n){const r=w(Ic)({type:"blockDetails",...t});return e.transport.request("explorer",r,n)}const kc=s(l({type:s(h("candleSnapshot"),i("Type of request.")),req:s(l({coin:s(k(),i("Asset symbol (e.g., BTC).")),interval:du,startTime:s(g,i("Start time (in ms since epoch).")),endTime:s(de(g),i("End time (in ms since epoch)."))}),i("Request parameters."))}),i("Request candlestick snapshots."));function Rc(e,t,n){const r=w(kc)({type:"candleSnapshot",req:t});return e.transport.request("info",r,n)}const Uc=s(l({type:s(h("clearinghouseState"),i("Type of request.")),user:s(q,i("User address.")),dex:s(E(k()),i("DEX name (empty string for main dex)."))}),i("Request clearinghouse state."));function Bc(e,t,n){const r=w(Uc)({type:"clearinghouseState",...t});return e.transport.request("info",r,n)}const $c=s(l({type:s(h("delegations"),i("Type of request.")),user:s(q,i("User address."))}),i("Request user staking delegations."));function Dc(e,t,n){const r=w($c)({type:"delegations",...t});return e.transport.request("info",r,n)}const Mc=s(l({type:s(h("delegatorHistory"),i("Type of request.")),user:s(q,i("User address."))}),i("Request user staking history."));function Fc(e,t,n){const r=w(Mc)({type:"delegatorHistory",...t});return e.transport.request("info",r,n)}const Oc=s(l({type:s(h("delegatorRewards"),i("Type of request.")),user:s(q,i("User address."))}),i("Request user staking rewards."));function Nc(e,t,n){const r=w(Oc)({type:"delegatorRewards",...t});return e.transport.request("info",r,n)}const Lc=s(l({type:s(h("delegatorSummary"),i("Type of request.")),user:s(q,i("User address."))}),i("Request user's staking summary."));function zc(e,t,n){const r=w(Lc)({type:"delegatorSummary",...t});return e.transport.request("info",r,n)}const _c=s(l({type:s(h("exchangeStatus"),i("Type of request."))}),i("Request exchange system status information."));function Hc(e,t){const n=w(_c)({type:"exchangeStatus"});return e.transport.request("info",n,t)}const Vc=s(l({type:s(h("extraAgents"),i("Type of request.")),user:s(q,i("User address."))}),i("Request user extra agents."));function Gc(e,t,n){const r=w(Vc)({type:"extraAgents",...t});return e.transport.request("info",r,n)}const jc=s(l({type:s(h("frontendOpenOrders"),i("Type of request.")),user:s(q,i("User address.")),dex:s(E(k()),i("DEX name (empty string for main dex)."))}),i("Request frontend open orders."));function Wc(e,t,n){const r=w(jc)({type:"frontendOpenOrders",...t});return e.transport.request("info",r,n)}const Xc=s(l({type:s(h("fundingHistory"),i("Type of request.")),coin:s(k(),i("Asset symbol (e.g., BTC).")),startTime:s(g,i("Start time (in ms since epoch).")),endTime:s(de(g),i("End time (in ms since epoch)."))}),i("Request funding history."));function Kc(e,t,n){const r=w(Xc)({type:"fundingHistory",...t});return e.transport.request("info",r,n)}const Yc=s(l({type:s(h("gossipRootIps"),i("Type of request."))}),i("Request gossip root IPs."));function Zc(e,t){const n=w(Yc)({type:"gossipRootIps"});return e.transport.request("info",n,t)}const Jc=s(l({type:s(h("historicalOrders"),i("Type of request.")),user:s(q,i("User address."))}),i("Request user historical orders."));function Qc(e,t,n){const r=w(Jc)({type:"historicalOrders",...t});return e.transport.request("info",r,n)}const ed=s(l({type:s(h("isVip"),i("Type of request.")),user:s(q,i("User address."))}),i("Request to check if a user is a VIP."));function td(e,t,n){const r=w(ed)({type:"isVip",...t});return e.transport.request("info",r,n)}const nd=s(l({type:s(h("l2Book"),i("Type of request.")),coin:s(k(),i("Asset symbol (e.g., BTC).")),nSigFigs:s(de(s(tr,M([h(2),h(3),h(4),h(5)]))),i("Number of significant figures.")),mantissa:s(de(s(tr,M([h(2),h(5)]))),i("Mantissa for aggregation (if `nSigFigs` is 5)."))}),i("Request L2 order book."));function rd(e,t,n){const r=w(nd)({type:"l2Book",...t});return e.transport.request("info",r,n)}const sd=s(l({type:s(h("leadingVaults"),i("Type of request.")),user:s(q,i("User address."))}),i("Request leading vaults for a user."));function id(e,t,n){const r=w(sd)({type:"leadingVaults",...t});return e.transport.request("info",r,n)}const od=s(l({type:s(h("legalCheck"),i("Type of request.")),user:s(q,i("User address."))}),i("Request legal verification status of a user."));function ad(e,t,n){const r=w(od)({type:"legalCheck",...t});return e.transport.request("info",r,n)}const ud=s(l({type:s(h("liquidatable"),i("Type of request."))}),i("Request liquidatable."));function cd(e,t){const n=w(ud)({type:"liquidatable"});return e.transport.request("info",n,t)}const dd=s(l({type:s(h("maxBuilderFee"),i("Type of request.")),user:s(q,i("User address.")),builder:s(q,i("Builder address."))}),i("Request builder fee approval."));function ld(e,t,n){const r=w(dd)({type:"maxBuilderFee",...t});return e.transport.request("info",r,n)}const fd=s(l({type:s(h("maxMarketOrderNtls"),i("Type of request."))}),i("Request maximum market order notionals."));function pd(e,t){const n=w(fd)({type:"maxMarketOrderNtls"});return e.transport.request("info",n,t)}const hd=s(l({type:s(h("metaAndAssetCtxs"),i("Type of request.")),dex:s(E(k()),i("DEX name (empty string for main dex)."))}),i("Request metadata and asset contexts."));function yd(e,t,n){const r=t instanceof AbortSignal?{}:t,o=t instanceof AbortSignal?t:n,a=w(hd)({type:"metaAndAssetCtxs",...r});return e.transport.request("info",a,o)}const md=s(l({type:s(h("openOrders"),i("Type of request.")),user:s(q,i("User address.")),dex:s(E(k()),i("DEX name (empty string for main dex)."))}),i("Request open orders."));function gd(e,t,n){const r=w(md)({type:"openOrders",...t});return e.transport.request("info",r,n)}const bd=s(l({type:s(h("orderStatus"),i("Type of request.")),user:s(q,i("User address.")),oid:s(M([g,s(z,ye(34))]),i("Order ID or Client Order ID."))}),i("Request order status."));function wd(e,t,n){const r=w(bd)({type:"orderStatus",...t});return e.transport.request("info",r,n)}const xd=s(l({type:s(h("perpDeployAuctionStatus"),i("Type of request."))}),i("Request for the status of the perpetual deploy auction."));function Ad(e,t){const n=w(xd)({type:"perpDeployAuctionStatus"});return e.transport.request("info",n,t)}const vd=s(l({type:s(h("perpDexLimits"),i("Type of request.")),dex:s(k(),i("DEX name (empty string for main dex)."))}),i("Request builder deployed perpetual market limits."));function qd(e,t,n){const r=w(vd)({type:"perpDexLimits",...t});return e.transport.request("info",r,n)}const Td=s(l({type:s(h("perpDexs"),i("Type of request."))}),i("Request all perpetual dexs."));function Ed(e,t){const n=w(Td)({type:"perpDexs"});return e.transport.request("info",n,t)}const Sd=s(l({type:s(h("perpsAtOpenInterestCap"),i("Type of request.")),dex:s(E(k()),i("DEX name (empty string for main dex)."))}),i("Request perpetuals at open interest cap."));function Cd(e,t,n){const r=t instanceof AbortSignal?{}:t,o=t instanceof AbortSignal?t:n,a=w(Sd)({type:"perpsAtOpenInterestCap",...r});return e.transport.request("info",a,o)}const Id=s(l({type:s(h("portfolio"),i("Type of request.")),user:s(q,i("User address."))}),i("Request user portfolio."));function Pd(e,t,n){const r=w(Id)({type:"portfolio",...t});return e.transport.request("info",r,n)}const kd=s(l({type:s(h("predictedFundings"),i("Type of request."))}),i("Request predicted funding rates."));function Rd(e,t){const n=w(kd)({type:"predictedFundings"});return e.transport.request("info",n,t)}const Ud=s(l({type:s(h("preTransferCheck"),i("Type of request.")),user:s(q,i("User address.")),source:s(q,i("Source address."))}),i("Request user existence check before transfer."));function Bd(e,t,n){const r=w(Ud)({type:"preTransferCheck",...t});return e.transport.request("info",r,n)}const $d=s(l({type:s(h("recentTrades"),i("Type of request.")),coin:s(k(),i("Asset symbol (e.g., BTC)."))}),i("Request recent trades."));function Dd(e,t,n){const r=w($d)({type:"recentTrades",...t});return e.transport.request("info",r,n)}const Md=s(l({type:s(h("referral"),i("Type of request.")),user:s(q,i("User address."))}),i("Request user referral."));function Fd(e,t,n){const r=w(Md)({type:"referral",...t});return e.transport.request("info",r,n)}const Od=s(l({type:s(h("spotClearinghouseState"),i("Type of request.")),user:s(q,i("User address.")),dex:s(E(k()),i("DEX name (empty string for main dex)."))}),i("Request spot clearinghouse state."));function Nd(e,t,n){const r=w(Od)({type:"spotClearinghouseState",...t});return e.transport.request("info",r,n)}const Ld=s(l({type:s(h("spotDeployState"),i("Type of request.")),user:s(q,i("User address."))}),i("Request spot deploy state."));function zd(e,t,n){const r=w(Ld)({type:"spotDeployState",...t});return e.transport.request("info",r,n)}const _d=s(l({type:s(h("spotMeta"),i("Type of request."))}),i("Request spot trading metadata."));function Hd(e,t){const n=w(_d)({type:"spotMeta"});return e.transport.request("info",n,t)}const Vd=s(l({type:s(h("spotMetaAndAssetCtxs"),i("Type of request."))}),i("Request spot metadata and asset contexts."));function Gd(e,t){const n=w(Vd)({type:"spotMetaAndAssetCtxs"});return e.transport.request("info",n,t)}const jd=s(l({type:s(h("spotPairDeployAuctionStatus"),i("Type of request."))}),i("Request for the status of the spot deploy auction."));function Wd(e,t){const n=w(jd)({type:"spotPairDeployAuctionStatus"});return e.transport.request("info",n,t)}const Xd=s(l({type:s(h("subAccounts"),i("Type of request.")),user:s(q,i("User address."))}),i("Request user sub-accounts."));function Kd(e,t,n){const r=w(Xd)({type:"subAccounts",...t});return e.transport.request("info",r,n)}const Yd=s(l({type:s(h("subAccounts2"),i("Type of request.")),user:s(q,i("User address."))}),i("Request user sub-accounts."));function Zd(e,t,n){const r=w(Yd)({type:"subAccounts2",...t});return e.transport.request("info",r,n)}const Jd=s(l({type:s(h("tokenDetails"),i("Type of request.")),tokenId:s(s(z,ye(34)),i("Token ID."))}),i("Request token details."));function Qd(e,t,n){const r=w(Jd)({type:"tokenDetails",...t});return e.transport.request("info",r,n)}const el=s(l({type:s(h("twapHistory"),i("Type of request.")),user:s(q,i("User address."))}),i("Request twap history of a user."));function tl(e,t,n){const r=w(el)({type:"twapHistory",...t});return e.transport.request("info",r,n)}const nl=s(l({type:s(h("txDetails"),i("Type of request.")),hash:s(s(z,ye(66)),i("Transaction hash."))}),i("Request transaction details by transaction hash."));function rl(e,t,n){const r=w(nl)({type:"txDetails",...t});return e.transport.request("explorer",r,n)}const sl=s(l({type:s(h("userDetails"),i("Type of request.")),user:s(q,i("User address."))}),i("Request array of user transaction details."));function il(e,t,n){const r=w(sl)({type:"userDetails",...t});return e.transport.request("explorer",r,n)}const ol=s(l({type:s(h("userDexAbstraction"),i("Type of request.")),user:s(q,i("User address."))}),i("Request user referral."));function al(e,t,n){const r=w(ol)({type:"userDexAbstraction",...t});return e.transport.request("info",r,n)}const ul=s(l({type:s(h("userFees"),i("Type of request.")),user:s(q,i("User address."))}),i("Request user fees."));function cl(e,t,n){const r=w(ul)({type:"userFees",...t});return e.transport.request("info",r,n)}const dl=s(l({type:s(h("userFills"),i("Type of request.")),user:s(q,i("User address.")),aggregateByTime:s(E(N()),i("If true, partial fills are aggregated when a crossing order fills multiple resting orders."))}),i("Request array of user fills."));function ll(e,t,n){const r=w(dl)({type:"userFills",...t});return e.transport.request("info",r,n)}const fl=s(l({type:s(h("userFillsByTime"),i("Type of request.")),user:s(q,i("User address.")),startTime:s(g,i("Start time (in ms since epoch).")),endTime:s(de(g),i("End time (in ms since epoch).")),aggregateByTime:s(E(N()),i("If true, partial fills are aggregated when a crossing order fills multiple resting orders."))}),i("Request array of user fills by time."));function pl(e,t,n){const r=w(fl)({type:"userFillsByTime",...t});return e.transport.request("info",r,n)}const hl=s(l({type:s(h("userFunding"),i("Type of request.")),user:s(q,i("User address.")),startTime:s(g,i("Start time (in ms since epoch).")),endTime:s(de(g),i("End time (in ms since epoch)."))}),i("Request array of user funding ledger updates."));function yl(e,t,n){const r=w(hl)({type:"userFunding",...t});return e.transport.request("info",r,n)}const ml=s(l({type:s(h("userNonFundingLedgerUpdates"),i("Type of request.")),user:s(q,i("User address.")),startTime:s(g,i("Start time (in ms since epoch).")),endTime:s(de(g),i("End time (in ms since epoch)."))}),i("Request user non-funding ledger updates."));function gl(e,t,n){const r=w(ml)({type:"userNonFundingLedgerUpdates",...t});return e.transport.request("info",r,n)}const bl=s(l({type:s(h("userRateLimit"),i("Type of request.")),user:s(q,i("User address."))}),i("Request user rate limits."));function wl(e,t,n){const r=w(bl)({type:"userRateLimit",...t});return e.transport.request("info",r,n)}const xl=s(l({type:s(h("userRole"),i("Type of request.")),user:s(q,i("User address."))}),i("Request user role."));function Al(e,t,n){const r=w(xl)({type:"userRole",...t});return e.transport.request("info",r,n)}const vl=s(l({type:s(h("userToMultiSigSigners"),i("Type of request.")),user:s(q,i("User address."))}),i("Request multi-sig signers for a user."));function ql(e,t,n){const r=w(vl)({type:"userToMultiSigSigners",...t});return e.transport.request("info",r,n)}const Tl=s(l({type:s(h("userTwapSliceFills"),i("Type of request.")),user:s(q,i("User address."))}),i("Request user TWAP slice fills."));function El(e,t,n){const r=w(Tl)({type:"userTwapSliceFills",...t});return e.transport.request("info",r,n)}const Sl=s(l({type:s(h("userTwapSliceFillsByTime"),i("Type of request.")),user:s(q,i("User address.")),startTime:s(g,i("Start time (in ms since epoch).")),endTime:s(de(g),i("End time (in ms since epoch).")),aggregateByTime:s(E(N()),i("If true, partial fills are aggregated when a crossing order fills multiple resting orders."))}),i("Request user TWAP slice fills by time."));function Cl(e,t,n){const r=w(Sl)({type:"userTwapSliceFillsByTime",...t});return e.transport.request("info",r,n)}const Il=s(l({type:s(h("userVaultEquities"),i("Type of request.")),user:s(q,i("User address."))}),i("Request user vault deposits."));function Pl(e,t,n){const r=w(Il)({type:"userVaultEquities",...t});return e.transport.request("info",r,n)}const kl=s(l({type:s(h("validatorL1Votes"),i("Type of request."))}),i("Request validator L1 votes."));function Rl(e,t){const n=w(kl)({type:"validatorL1Votes"});return e.transport.request("info",n,t)}const Ul=s(l({type:s(h("validatorSummaries"),i("Type of request."))}),i("Request validator summaries."));function Bl(e,t){const n=w(Ul)({type:"validatorSummaries"});return e.transport.request("info",n,t)}const $l=s(l({type:s(h("vaultDetails"),i("Type of request.")),vaultAddress:s(q,i("Vault address.")),user:s(de(q),i("User address."))}),i("Request details of a vault."));function Dl(e,t,n){const r=w($l)({type:"vaultDetails",...t});return e.transport.request("info",r,n)}const Ml=s(l({type:s(h("vaultSummaries"),i("Type of request."))}),i("Request a list of vaults less than 2 hours old."));function Fl(e,t){const n=w(Ml)({type:"vaultSummaries"});return e.transport.request("info",n,t)}const Ol=s(l({type:s(h("webData2"),i("Type of request.")),user:s(q,i("User address."))}),i("Request comprehensive user and market data."));function Nl(e,t,n){const r=w(Ol)({type:"webData2",...t});return e.transport.request("info",r,n)}class po{transport;constructor(t){this.transport=t.transport}activeAssetData(...t){return gc(this,...t)}alignedQuoteTokenInfo(...t){return wc(this,...t)}allMids(...t){return Ac(this,...t)}allPerpMetas(){return Cc(this)}blockDetails(...t){return Pc(this,...t)}candleSnapshot(...t){return Rc(this,...t)}clearinghouseState(...t){return Bc(this,...t)}delegations(...t){return Dc(this,...t)}delegatorHistory(...t){return Fc(this,...t)}delegatorRewards(...t){return Nc(this,...t)}delegatorSummary(...t){return zc(this,...t)}exchangeStatus(...t){return Hc(this,...t)}extraAgents(...t){return Gc(this,...t)}frontendOpenOrders(...t){return Wc(this,...t)}fundingHistory(...t){return Kc(this,...t)}gossipRootIps(...t){return Zc(this,...t)}historicalOrders(...t){return Qc(this,...t)}isVip(...t){return td(this,...t)}l2Book(...t){return rd(this,...t)}leadingVaults(...t){return id(this,...t)}legalCheck(...t){return ad(this,...t)}liquidatable(...t){return cd(this,...t)}marginTable(...t){return qc(this,...t)}maxBuilderFee(...t){return ld(this,...t)}maxMarketOrderNtls(...t){return pd(this,...t)}meta(...t){return Ec(this,...t)}metaAndAssetCtxs(...t){return yd(this,...t)}openOrders(...t){return gd(this,...t)}orderStatus(...t){return wd(this,...t)}perpDeployAuctionStatus(...t){return Ad(this,...t)}perpDexLimits(...t){return qd(this,...t)}perpDexs(...t){return Ed(this,...t)}perpsAtOpenInterestCap(...t){return Cd(this,...t)}portfolio(...t){return Pd(this,...t)}predictedFundings(...t){return Rd(this,...t)}preTransferCheck(...t){return Bd(this,...t)}recentTrades(...t){return Dd(this,...t)}referral(...t){return Fd(this,...t)}spotClearinghouseState(...t){return Nd(this,...t)}spotDeployState(...t){return zd(this,...t)}spotMeta(...t){return Hd(this,...t)}spotMetaAndAssetCtxs(...t){return Gd(this,...t)}spotPairDeployAuctionStatus(...t){return Wd(this,...t)}subAccounts(...t){return Kd(this,...t)}subAccounts2(...t){return Zd(this,...t)}tokenDetails(...t){return Qd(this,...t)}twapHistory(...t){return tl(this,...t)}txDetails(...t){return rl(this,...t)}userDetails(...t){return il(this,...t)}userDexAbstraction(...t){return al(this,...t)}userFees(...t){return cl(this,...t)}userFills(...t){return ll(this,...t)}userFillsByTime(...t){return pl(this,...t)}userFunding(...t){return yl(this,...t)}userNonFundingLedgerUpdates(...t){return gl(this,...t)}userRateLimit(...t){return wl(this,...t)}userRole(...t){return Al(this,...t)}userToMultiSigSigners(...t){return ql(this,...t)}userTwapSliceFills(...t){return El(this,...t)}userTwapSliceFillsByTime(...t){return Cl(this,...t)}userVaultEquities(...t){return Pl(this,...t)}validatorL1Votes(...t){return Rl(this,...t)}validatorSummaries(...t){return Bl(this,...t)}vaultDetails(...t){return Dl(this,...t)}vaultSummaries(...t){return Fl(this,...t)}webData2(...t){return Nl(this,...t)}}function Ll(e,t){return e.exec(t)?.groups}const Cs=/^tuple(?<array>(\[(\d*)\])*)$/;function dr(e){let t=e.type;if(Cs.test(e.type)&&"components"in e){t="(";const n=e.components.length;for(let o=0;o<n;o++){const a=e.components[o];t+=dr(a),o<n-1&&(t+=", ")}const r=Ll(Cs,e.type);return t+=`)${r?.array??""}`,dr({...e,type:t})}return"indexed"in e&&e.indexed&&(t=`${t} indexed`),e.name?`${t} ${e.name}`:t}function yt(e){let t="";const n=e.length;for(let r=0;r<n;r++){const o=e[r];t+=dr(o),r!==n-1&&(t+=", ")}return t}function zl(e){return e.type==="function"?`function ${e.name}(${yt(e.inputs)})${e.stateMutability&&e.stateMutability!=="nonpayable"?` ${e.stateMutability}`:""}${e.outputs?.length?` returns (${yt(e.outputs)})`:""}`:e.type==="event"?`event ${e.name}(${yt(e.inputs)})`:e.type==="error"?`error ${e.name}(${yt(e.inputs)})`:e.type==="constructor"?`constructor(${yt(e.inputs)})${e.stateMutability==="payable"?" payable":""}`:e.type==="fallback"?`fallback() external${e.stateMutability==="payable"?" payable":""}`:"receive() external payable"}function O(e,t,n){const r=e[t.name];if(typeof r=="function")return r;const o=e[n];return typeof o=="function"?o:a=>t(e,a)}function it(e,{includeName:t=!1}={}){if(e.type!=="function"&&e.type!=="event"&&e.type!=="error")throw new Ql(e.type);return`${e.name}(${zr(e.inputs,{includeName:t})})`}function zr(e,{includeName:t=!1}={}){return e?e.map(n=>_l(n,{includeName:t})).join(t?", ":","):""}function _l(e,{includeName:t}){return e.type.startsWith("tuple")?`(${zr(e.components,{includeName:t})})${e.type.slice(5)}`:e.type+(t&&e.name?` ${e.name}`:"")}function Fe(e,{strict:t=!0}={}){return!e||typeof e!="string"?!1:t?/^0x[0-9a-fA-F]*$/.test(e):e.startsWith("0x")}function X(e){return Fe(e,{strict:!1})?Math.ceil((e.length-2)/2):e.length}const ho="2.40.3";let Hn={getDocsUrl:({docsBaseUrl:e,docsPath:t="",docsSlug:n})=>t?`${e??"https://viem.sh"}${t}${n?`#${n}`:""}`:void 0,version:`viem@${ho}`};class v extends Error{constructor(t,n={}){const r=n.cause instanceof v?n.cause.details:n.cause?.message?n.cause.message:n.details,o=n.cause instanceof v&&n.cause.docsPath||n.docsPath,a=Hn.getDocsUrl?.({...n,docsPath:o}),u=[t||"An error occurred.","",...n.metaMessages?[...n.metaMessages,""]:[],...a?[`Docs: ${a}`]:[],...r?[`Details: ${r}`]:[],...Hn.version?[`Version: ${Hn.version}`]:[]].join(`
`);super(u,n.cause?{cause:n.cause}:void 0),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"version",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"BaseError"}),this.details=r,this.docsPath=o,this.metaMessages=n.metaMessages,this.name=n.name??this.name,this.shortMessage=t,this.version=ho}walk(t){return yo(this,t)}}function yo(e,t){return t?.(e)?e:e&&typeof e=="object"&&"cause"in e&&e.cause!==void 0?yo(e.cause,t):t?null:e}class Hl extends v{constructor({docsPath:t}){super(["A constructor was not found on the ABI.","Make sure you are using the correct ABI and that the constructor exists on it."].join(`
`),{docsPath:t,name:"AbiConstructorNotFoundError"})}}class Is extends v{constructor({docsPath:t}){super(["Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.","Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."].join(`
`),{docsPath:t,name:"AbiConstructorParamsNotFoundError"})}}class Vl extends v{constructor({data:t,params:n,size:r}){super([`Data size of ${r} bytes is too small for given parameters.`].join(`
`),{metaMessages:[`Params: (${zr(n,{includeName:!0})})`,`Data:   ${t} (${r} bytes)`],name:"AbiDecodingDataSizeTooSmallError"}),Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"params",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"size",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.data=t,this.params=n,this.size=r}}class _r extends v{constructor(){super('Cannot decode zero data ("0x") with ABI parameters.',{name:"AbiDecodingZeroDataError"})}}class Gl extends v{constructor({expectedLength:t,givenLength:n,type:r}){super([`ABI encoding array length mismatch for type ${r}.`,`Expected length: ${t}`,`Given length: ${n}`].join(`
`),{name:"AbiEncodingArrayLengthMismatchError"})}}class jl extends v{constructor({expectedSize:t,value:n}){super(`Size of bytes "${n}" (bytes${X(n)}) does not match expected size (bytes${t}).`,{name:"AbiEncodingBytesSizeMismatchError"})}}class Wl extends v{constructor({expectedLength:t,givenLength:n}){super(["ABI encoding params/values length mismatch.",`Expected length (params): ${t}`,`Given length (values): ${n}`].join(`
`),{name:"AbiEncodingLengthMismatchError"})}}class mo extends v{constructor(t,{docsPath:n}){super([`Encoded error signature "${t}" not found on ABI.`,"Make sure you are using the correct ABI and that the error exists on it.",`You can look up the decoded signature here: https://openchain.xyz/signatures?query=${t}.`].join(`
`),{docsPath:n,name:"AbiErrorSignatureNotFoundError"}),Object.defineProperty(this,"signature",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.signature=t}}class Ps extends v{constructor(t,{docsPath:n}={}){super([`Function ${t?`"${t}" `:""}not found on ABI.`,"Make sure you are using the correct ABI and that the function exists on it."].join(`
`),{docsPath:n,name:"AbiFunctionNotFoundError"})}}class Xl extends v{constructor(t,n){super("Found ambiguous types in overloaded ABI items.",{metaMessages:[`\`${t.type}\` in \`${it(t.abiItem)}\`, and`,`\`${n.type}\` in \`${it(n.abiItem)}\``,"","These types encode differently and cannot be distinguished at runtime.","Remove one of the ambiguous items in the ABI."],name:"AbiItemAmbiguityError"})}}class Kl extends v{constructor({expectedSize:t,givenSize:n}){super(`Expected bytes${t}, got bytes${n}.`,{name:"BytesSizeMismatchError"})}}class Yl extends v{constructor(t,{docsPath:n}){super([`Type "${t}" is not a valid encoding type.`,"Please provide a valid ABI type."].join(`
`),{docsPath:n,name:"InvalidAbiEncodingType"})}}class Zl extends v{constructor(t,{docsPath:n}){super([`Type "${t}" is not a valid decoding type.`,"Please provide a valid ABI type."].join(`
`),{docsPath:n,name:"InvalidAbiDecodingType"})}}class Jl extends v{constructor(t){super([`Value "${t}" is not a valid array.`].join(`
`),{name:"InvalidArrayError"})}}class Ql extends v{constructor(t){super([`"${t}" is not a valid definition type.`,'Valid types: "function", "event", "error"'].join(`
`),{name:"InvalidDefinitionTypeError"})}}class go extends v{constructor({offset:t,position:n,size:r}){super(`Slice ${n==="start"?"starting":"ending"} at offset "${t}" is out-of-bounds (size: ${r}).`,{name:"SliceOffsetOutOfBoundsError"})}}class bo extends v{constructor({size:t,targetSize:n,type:r}){super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (${t}) exceeds padding size (${n}).`,{name:"SizeExceedsPaddingSizeError"})}}class ks extends v{constructor({size:t,targetSize:n,type:r}){super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} is expected to be ${n} ${r} long, but is ${t} ${r} long.`,{name:"InvalidBytesLengthError"})}}function lt(e,{dir:t,size:n=32}={}){return typeof e=="string"?Be(e,{dir:t,size:n}):ef(e,{dir:t,size:n})}function Be(e,{dir:t,size:n=32}={}){if(n===null)return e;const r=e.replace("0x","");if(r.length>n*2)throw new bo({size:Math.ceil(r.length/2),targetSize:n,type:"hex"});return`0x${r[t==="right"?"padEnd":"padStart"](n*2,"0")}`}function ef(e,{dir:t,size:n=32}={}){if(n===null)return e;if(e.length>n)throw new bo({size:e.length,targetSize:n,type:"bytes"});const r=new Uint8Array(n);for(let o=0;o<n;o++){const a=t==="right";r[a?o:n-o-1]=e[a?o:e.length-o-1]}return r}class wo extends v{constructor({max:t,min:n,signed:r,size:o,value:a}){super(`Number "${a}" is not in safe ${o?`${o*8}-bit ${r?"signed":"unsigned"} `:""}integer range ${t?`(${n} to ${t})`:`(above ${n})`}`,{name:"IntegerOutOfRangeError"})}}class tf extends v{constructor(t){super(`Bytes value "${t}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`,{name:"InvalidBytesBooleanError"})}}class nf extends v{constructor({givenSize:t,maxSize:n}){super(`Size cannot exceed ${n} bytes. Given size: ${t} bytes.`,{name:"SizeOverflowError"})}}function Cn(e,{dir:t="left"}={}){let n=typeof e=="string"?e.replace("0x",""):e,r=0;for(let o=0;o<n.length-1&&n[t==="left"?o:n.length-o-1].toString()==="0";o++)r++;return n=t==="left"?n.slice(r):n.slice(0,n.length-r),typeof e=="string"?(n.length===1&&t==="right"&&(n=`${n}0`),`0x${n.length%2===1?`0${n}`:n}`):n}function ve(e,{size:t}){if(X(e)>t)throw new nf({givenSize:X(e),maxSize:t})}function Ce(e,t={}){const{signed:n}=t;t.size&&ve(e,{size:t.size});const r=BigInt(e);if(!n)return r;const o=(e.length-2)/2,a=(1n<<BigInt(o)*8n-1n)-1n;return r<=a?r:r-BigInt(`0x${"f".padStart(o*2,"f")}`)-1n}function Ie(e,t={}){return Number(Ce(e,t))}const rf=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function yn(e,t={}){return typeof e=="number"||typeof e=="bigint"?$(e,t):typeof e=="string"?In(e,t):typeof e=="boolean"?xo(e,t):ee(e,t)}function xo(e,t={}){const n=`0x${Number(e)}`;return typeof t.size=="number"?(ve(n,{size:t.size}),lt(n,{size:t.size})):n}function ee(e,t={}){let n="";for(let o=0;o<e.length;o++)n+=rf[e[o]];const r=`0x${n}`;return typeof t.size=="number"?(ve(r,{size:t.size}),lt(r,{dir:"right",size:t.size})):r}function $(e,t={}){const{signed:n,size:r}=t,o=BigInt(e);let a;r?n?a=(1n<<BigInt(r)*8n-1n)-1n:a=2n**(BigInt(r)*8n)-1n:typeof e=="number"&&(a=BigInt(Number.MAX_SAFE_INTEGER));const u=typeof a=="bigint"&&n?-a-1n:0;if(a&&o>a||o<u){const d=typeof e=="bigint"?"n":"";throw new wo({max:a?`${a}${d}`:void 0,min:`${u}${d}`,signed:n,size:r,value:`${e}${d}`})}const c=`0x${(n&&o<0?(1n<<BigInt(r*8))+BigInt(o):o).toString(16)}`;return r?lt(c,{size:r}):c}const sf=new TextEncoder;function In(e,t={}){const n=sf.encode(e);return ee(n,t)}const of=new TextEncoder;function Hr(e,t={}){return typeof e=="number"||typeof e=="bigint"?uf(e,t):typeof e=="boolean"?af(e,t):Fe(e)?Pe(e,t):Ao(e,t)}function af(e,t={}){const n=new Uint8Array(1);return n[0]=Number(e),typeof t.size=="number"?(ve(n,{size:t.size}),lt(n,{size:t.size})):n}const Ee={zero:48,nine:57,A:65,F:70,a:97,f:102};function Rs(e){if(e>=Ee.zero&&e<=Ee.nine)return e-Ee.zero;if(e>=Ee.A&&e<=Ee.F)return e-(Ee.A-10);if(e>=Ee.a&&e<=Ee.f)return e-(Ee.a-10)}function Pe(e,t={}){let n=e;t.size&&(ve(n,{size:t.size}),n=lt(n,{dir:"right",size:t.size}));let r=n.slice(2);r.length%2&&(r=`0${r}`);const o=r.length/2,a=new Uint8Array(o);for(let u=0,c=0;u<o;u++){const d=Rs(r.charCodeAt(c++)),p=Rs(r.charCodeAt(c++));if(d===void 0||p===void 0)throw new v(`Invalid byte sequence ("${r[c-2]}${r[c-1]}" in "${r}").`);a[u]=d*16+p}return a}function uf(e,t){const n=$(e,t);return Pe(n)}function Ao(e,t={}){const n=of.encode(e);return typeof t.size=="number"?(ve(n,{size:t.size}),lt(n,{dir:"right",size:t.size})):n}const rn=BigInt(2**32-1),Us=BigInt(32);function cf(e,t=!1){return t?{h:Number(e&rn),l:Number(e>>Us&rn)}:{h:Number(e>>Us&rn)|0,l:Number(e&rn)|0}}function df(e,t=!1){const n=e.length;let r=new Uint32Array(n),o=new Uint32Array(n);for(let a=0;a<n;a++){const{h:u,l:c}=cf(e[a],t);[r[a],o[a]]=[u,c]}return[r,o]}const lf=(e,t,n)=>e<<n|t>>>32-n,ff=(e,t,n)=>t<<n|e>>>32-n,pf=(e,t,n)=>t<<n-32|e>>>64-n,hf=(e,t,n)=>e<<n-32|t>>>64-n;function yf(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Bs(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function Ct(e,...t){if(!yf(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function mn(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function vo(e,t){Ct(e);const n=t.outputLen;if(e.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}function mf(e){return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}function It(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function Vn(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function be(e,t){return e<<32-t|e>>>t}const gf=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function bf(e){return e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255}function wf(e){for(let t=0;t<e.length;t++)e[t]=bf(e[t]);return e}const $s=gf?e=>e:wf;function xf(e){if(typeof e!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(e))}function Vr(e){return typeof e=="string"&&(e=xf(e)),Ct(e),e}class qo{}function To(e){const t=r=>e().update(Vr(r)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}const Af=BigInt(0),mt=BigInt(1),vf=BigInt(2),qf=BigInt(7),Tf=BigInt(256),Ef=BigInt(113),Eo=[],So=[],Co=[];for(let e=0,t=mt,n=1,r=0;e<24;e++){[n,r]=[r,(2*n+3*r)%5],Eo.push(2*(5*r+n)),So.push((e+1)*(e+2)/2%64);let o=Af;for(let a=0;a<7;a++)t=(t<<mt^(t>>qf)*Ef)%Tf,t&vf&&(o^=mt<<(mt<<BigInt(a))-mt);Co.push(o)}const Io=df(Co,!0),Sf=Io[0],Cf=Io[1],Ds=(e,t,n)=>n>32?pf(e,t,n):lf(e,t,n),Ms=(e,t,n)=>n>32?hf(e,t,n):ff(e,t,n);function If(e,t=24){const n=new Uint32Array(10);for(let r=24-t;r<24;r++){for(let u=0;u<10;u++)n[u]=e[u]^e[u+10]^e[u+20]^e[u+30]^e[u+40];for(let u=0;u<10;u+=2){const c=(u+8)%10,d=(u+2)%10,p=n[d],f=n[d+1],m=Ds(p,f,1)^n[c],y=Ms(p,f,1)^n[c+1];for(let b=0;b<50;b+=10)e[u+b]^=m,e[u+b+1]^=y}let o=e[2],a=e[3];for(let u=0;u<24;u++){const c=So[u],d=Ds(o,a,c),p=Ms(o,a,c),f=Eo[u];o=e[f],a=e[f+1],e[f]=d,e[f+1]=p}for(let u=0;u<50;u+=10){for(let c=0;c<10;c++)n[c]=e[u+c];for(let c=0;c<10;c++)e[u+c]^=~n[(c+2)%10]&n[(c+4)%10]}e[0]^=Sf[r],e[1]^=Cf[r]}It(n)}class Gr extends qo{constructor(t,n,r,o=!1,a=24){if(super(),this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,this.enableXOF=!1,this.blockLen=t,this.suffix=n,this.outputLen=r,this.enableXOF=o,this.rounds=a,Bs(r),!(0<t&&t<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=mf(this.state)}clone(){return this._cloneInto()}keccak(){$s(this.state32),If(this.state32,this.rounds),$s(this.state32),this.posOut=0,this.pos=0}update(t){mn(this),t=Vr(t),Ct(t);const{blockLen:n,state:r}=this,o=t.length;for(let a=0;a<o;){const u=Math.min(n-this.pos,o-a);for(let c=0;c<u;c++)r[this.pos++]^=t[a++];this.pos===n&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:n,pos:r,blockLen:o}=this;t[r]^=n,(n&128)!==0&&r===o-1&&this.keccak(),t[o-1]^=128,this.keccak()}writeInto(t){mn(this,!1),Ct(t),this.finish();const n=this.state,{blockLen:r}=this;for(let o=0,a=t.length;o<a;){this.posOut>=r&&this.keccak();const u=Math.min(r-this.posOut,a-o);t.set(n.subarray(this.posOut,this.posOut+u),o),this.posOut+=u,o+=u}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return Bs(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(vo(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,It(this.state)}_cloneInto(t){const{blockLen:n,suffix:r,outputLen:o,rounds:a,enableXOF:u}=this;return t||(t=new Gr(n,r,o,u,a)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=a,t.suffix=r,t.outputLen=o,t.enableXOF=u,t.destroyed=this.destroyed,t}}const Pf=(e,t,n)=>To(()=>new Gr(t,e,n)),kf=Pf(1,136,256/8);function Pn(e,t){const n=t||"hex",r=kf(Fe(e,{strict:!1})?Hr(e):e);return n==="bytes"?r:yn(r)}const Rf=e=>Pn(Hr(e));function Uf(e){return Rf(e)}function Bf(e){let t=!0,n="",r=0,o="",a=!1;for(let u=0;u<e.length;u++){const c=e[u];if(["(",")",","].includes(c)&&(t=!0),c==="("&&r++,c===")"&&r--,!!t){if(r===0){if(c===" "&&["event","function",""].includes(o))o="";else if(o+=c,c===")"){a=!0;break}continue}if(c===" "){e[u-1]!==","&&n!==","&&n!==",("&&(n="",t=!1);continue}o+=c,n+=c}}if(!a)throw new v("Unable to normalize signature.");return o}const $f=e=>{const t=typeof e=="string"?e:zl(e);return Bf(t)};function Po(e){return Uf($f(e))}const Df=Po;class Oe extends v{constructor({address:t}){super(`Address "${t}" is invalid.`,{metaMessages:["- Address must be a hex value of 20 bytes (40 hex characters).","- Address must match its checksum counterpart."],name:"InvalidAddressError"})}}class ft extends Map{constructor(t){super(),Object.defineProperty(this,"maxSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxSize=t}get(t){const n=super.get(t);return super.has(t)&&n!==void 0&&(this.delete(t),super.set(t,n)),n}set(t,n){if(super.set(t,n),this.maxSize&&this.size>this.maxSize){const r=this.keys().next().value;r&&this.delete(r)}return this}}const Gn=new ft(8192);function Qt(e,t){if(Gn.has(`${e}.${t}`))return Gn.get(`${e}.${t}`);const n=e.substring(2).toLowerCase(),r=Pn(Ao(n),"bytes"),o=n.split("");for(let u=0;u<40;u+=2)r[u>>1]>>4>=8&&o[u]&&(o[u]=o[u].toUpperCase()),(r[u>>1]&15)>=8&&o[u+1]&&(o[u+1]=o[u+1].toUpperCase());const a=`0x${o.join("")}`;return Gn.set(`${e}.${t}`,a),a}function ko(e,t){if(!ie(e,{strict:!1}))throw new Oe({address:e});return Qt(e,t)}const Mf=/^0x[a-fA-F0-9]{40}$/,jn=new ft(8192);function ie(e,t){const{strict:n=!0}=t??{},r=`${e}.${n}`;if(jn.has(r))return jn.get(r);const o=Mf.test(e)?e.toLowerCase()===e?!0:n?Qt(e)===e:!0:!1;return jn.set(r,o),o}function Ne(e){return typeof e[0]=="string"?kn(e):Ff(e)}function Ff(e){let t=0;for(const o of e)t+=o.length;const n=new Uint8Array(t);let r=0;for(const o of e)n.set(o,r),r+=o.length;return n}function kn(e){return`0x${e.reduce((t,n)=>t+n.replace("0x",""),"")}`}function gn(e,t,n,{strict:r}={}){return Fe(e,{strict:!1})?lr(e,t,n,{strict:r}):Bo(e,t,n,{strict:r})}function Ro(e,t){if(typeof t=="number"&&t>0&&t>X(e)-1)throw new go({offset:t,position:"start",size:X(e)})}function Uo(e,t,n){if(typeof t=="number"&&typeof n=="number"&&X(e)!==n-t)throw new go({offset:n,position:"end",size:X(e)})}function Bo(e,t,n,{strict:r}={}){Ro(e,t);const o=e.slice(t,n);return r&&Uo(o,t,n),o}function lr(e,t,n,{strict:r}={}){Ro(e,t);const o=`0x${e.replace("0x","").slice((t??0)*2,(n??e.length)*2)}`;return r&&Uo(o,t,n),o}const Of=/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,$o=/^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;function Do(e,t){if(e.length!==t.length)throw new Wl({expectedLength:e.length,givenLength:t.length});const n=Nf({params:e,values:t}),r=Wr(n);return r.length===0?"0x":r}function Nf({params:e,values:t}){const n=[];for(let r=0;r<e.length;r++)n.push(jr({param:e[r],value:t[r]}));return n}function jr({param:e,value:t}){const n=Xr(e.type);if(n){const[r,o]=n;return zf(t,{length:r,param:{...e,type:o}})}if(e.type==="tuple")return jf(t,{param:e});if(e.type==="address")return Lf(t);if(e.type==="bool")return Hf(t);if(e.type.startsWith("uint")||e.type.startsWith("int")){const r=e.type.startsWith("int"),[,,o="256"]=$o.exec(e.type)??[];return Vf(t,{signed:r,size:Number(o)})}if(e.type.startsWith("bytes"))return _f(t,{param:e});if(e.type==="string")return Gf(t);throw new Yl(e.type,{docsPath:"/docs/contract/encodeAbiParameters"})}function Wr(e){let t=0;for(let a=0;a<e.length;a++){const{dynamic:u,encoded:c}=e[a];u?t+=32:t+=X(c)}const n=[],r=[];let o=0;for(let a=0;a<e.length;a++){const{dynamic:u,encoded:c}=e[a];u?(n.push($(t+o,{size:32})),r.push(c),o+=X(c)):n.push(c)}return Ne([...n,...r])}function Lf(e){if(!ie(e))throw new Oe({address:e});return{dynamic:!1,encoded:Be(e.toLowerCase())}}function zf(e,{length:t,param:n}){const r=t===null;if(!Array.isArray(e))throw new Jl(e);if(!r&&e.length!==t)throw new Gl({expectedLength:t,givenLength:e.length,type:`${n.type}[${t}]`});let o=!1;const a=[];for(let u=0;u<e.length;u++){const c=jr({param:n,value:e[u]});c.dynamic&&(o=!0),a.push(c)}if(r||o){const u=Wr(a);if(r){const c=$(a.length,{size:32});return{dynamic:!0,encoded:a.length>0?Ne([c,u]):c}}if(o)return{dynamic:!0,encoded:u}}return{dynamic:!1,encoded:Ne(a.map(({encoded:u})=>u))}}function _f(e,{param:t}){const[,n]=t.type.split("bytes"),r=X(e);if(!n){let o=e;return r%32!==0&&(o=Be(o,{dir:"right",size:Math.ceil((e.length-2)/2/32)*32})),{dynamic:!0,encoded:Ne([Be($(r,{size:32})),o])}}if(r!==Number.parseInt(n,10))throw new jl({expectedSize:Number.parseInt(n,10),value:e});return{dynamic:!1,encoded:Be(e,{dir:"right"})}}function Hf(e){if(typeof e!="boolean")throw new v(`Invalid boolean value: "${e}" (type: ${typeof e}). Expected: \`true\` or \`false\`.`);return{dynamic:!1,encoded:Be(xo(e))}}function Vf(e,{signed:t,size:n=256}){if(typeof n=="number"){const r=2n**(BigInt(n)-(t?1n:0n))-1n,o=t?-r-1n:0n;if(e>r||e<o)throw new wo({max:r.toString(),min:o.toString(),signed:t,size:n/8,value:e.toString()})}return{dynamic:!1,encoded:$(e,{size:32,signed:t})}}function Gf(e){const t=In(e),n=Math.ceil(X(t)/32),r=[];for(let o=0;o<n;o++)r.push(Be(gn(t,o*32,(o+1)*32),{dir:"right"}));return{dynamic:!0,encoded:Ne([Be($(X(t),{size:32})),...r])}}function jf(e,{param:t}){let n=!1;const r=[];for(let o=0;o<t.components.length;o++){const a=t.components[o],u=Array.isArray(e)?o:a.name,c=jr({param:a,value:e[u]});r.push(c),c.dynamic&&(n=!0)}return{dynamic:n,encoded:n?Wr(r):Ne(r.map(({encoded:o})=>o))}}function Xr(e){const t=e.match(/^(.*)\[(\d+)?\]$/);return t?[t[2]?Number(t[2]):null,t[1]]:void 0}const Kr=e=>gn(Po(e),0,4);function Mo(e){const{abi:t,args:n=[],name:r}=e,o=Fe(r,{strict:!1}),a=t.filter(c=>o?c.type==="function"?Kr(c)===r:c.type==="event"?Df(c)===r:!1:"name"in c&&c.name===r);if(a.length===0)return;if(a.length===1)return a[0];let u;for(const c of a){if(!("inputs"in c))continue;if(!n||n.length===0){if(!c.inputs||c.inputs.length===0)return c;continue}if(!c.inputs||c.inputs.length===0||c.inputs.length!==n.length)continue;if(n.every((p,f)=>{const m="inputs"in c&&c.inputs[f];return m?fr(p,m):!1})){if(u&&"inputs"in u&&u.inputs){const p=Fo(c.inputs,u.inputs,n);if(p)throw new Xl({abiItem:c,type:p[0]},{abiItem:u,type:p[1]})}u=c}}return u||a[0]}function fr(e,t){const n=typeof e,r=t.type;switch(r){case"address":return ie(e,{strict:!1});case"bool":return n==="boolean";case"function":return n==="string";case"string":return n==="string";default:return r==="tuple"&&"components"in t?Object.values(t.components).every((o,a)=>fr(Object.values(e)[a],o)):/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(r)?n==="number"||n==="bigint":/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(r)?n==="string"||e instanceof Uint8Array:/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(r)?Array.isArray(e)&&e.every(o=>fr(o,{...t,type:r.replace(/(\[[0-9]{0,}\])$/,"")})):!1}}function Fo(e,t,n){for(const r in e){const o=e[r],a=t[r];if(o.type==="tuple"&&a.type==="tuple"&&"components"in o&&"components"in a)return Fo(o.components,a.components,n[r]);const u=[o.type,a.type];if(u.includes("address")&&u.includes("bytes20")?!0:u.includes("address")&&u.includes("string")?ie(n[r],{strict:!1}):u.includes("address")&&u.includes("bytes")?ie(n[r],{strict:!1}):!1)return u}}function J(e){return typeof e=="string"?{address:e,type:"json-rpc"}:e}const Fs="/docs/contract/encodeFunctionData";function Wf(e){const{abi:t,args:n,functionName:r}=e;let o=t[0];if(r){const a=Mo({abi:t,args:n,name:r});if(!a)throw new Ps(r,{docsPath:Fs});o=a}if(o.type!=="function")throw new Ps(void 0,{docsPath:Fs});return{abi:[o],functionName:Kr(it(o))}}function Oo(e){const{args:t}=e,{abi:n,functionName:r}=e.abi.length===1&&e.functionName?.startsWith("0x")?e:Wf(e),o=n[0],a=r,u="inputs"in o&&o.inputs?Do(o.inputs,t??[]):void 0;return kn([a,u??"0x"])}const Xf={1:"An `assert` condition failed.",17:"Arithmetic operation resulted in underflow or overflow.",18:"Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",33:"Attempted to convert to an invalid type.",34:"Attempted to access a storage byte array that is incorrectly encoded.",49:"Performed `.pop()` on an empty array",50:"Array index is out of bounds.",65:"Allocated too much memory or created an array which is too large.",81:"Attempted to call a zero-initialized variable of internal function type."},Kf={inputs:[{name:"message",type:"string"}],name:"Error",type:"error"},Yf={inputs:[{name:"reason",type:"uint256"}],name:"Panic",type:"error"};class Os extends v{constructor({offset:t}){super(`Offset \`${t}\` cannot be negative.`,{name:"NegativeOffsetError"})}}class Zf extends v{constructor({length:t,position:n}){super(`Position \`${n}\` is out of bounds (\`0 < position < ${t}\`).`,{name:"PositionOutOfBoundsError"})}}class Jf extends v{constructor({count:t,limit:n}){super(`Recursive read limit of \`${n}\` exceeded (recursive read count: \`${t}\`).`,{name:"RecursiveReadLimitExceededError"})}}const Qf={bytes:new Uint8Array,dataView:new DataView(new ArrayBuffer(0)),position:0,positionReadCount:new Map,recursiveReadCount:0,recursiveReadLimit:Number.POSITIVE_INFINITY,assertReadLimit(){if(this.recursiveReadCount>=this.recursiveReadLimit)throw new Jf({count:this.recursiveReadCount+1,limit:this.recursiveReadLimit})},assertPosition(e){if(e<0||e>this.bytes.length-1)throw new Zf({length:this.bytes.length,position:e})},decrementPosition(e){if(e<0)throw new Os({offset:e});const t=this.position-e;this.assertPosition(t),this.position=t},getReadCount(e){return this.positionReadCount.get(e||this.position)||0},incrementPosition(e){if(e<0)throw new Os({offset:e});const t=this.position+e;this.assertPosition(t),this.position=t},inspectByte(e){const t=e??this.position;return this.assertPosition(t),this.bytes[t]},inspectBytes(e,t){const n=t??this.position;return this.assertPosition(n+e-1),this.bytes.subarray(n,n+e)},inspectUint8(e){const t=e??this.position;return this.assertPosition(t),this.bytes[t]},inspectUint16(e){const t=e??this.position;return this.assertPosition(t+1),this.dataView.getUint16(t)},inspectUint24(e){const t=e??this.position;return this.assertPosition(t+2),(this.dataView.getUint16(t)<<8)+this.dataView.getUint8(t+2)},inspectUint32(e){const t=e??this.position;return this.assertPosition(t+3),this.dataView.getUint32(t)},pushByte(e){this.assertPosition(this.position),this.bytes[this.position]=e,this.position++},pushBytes(e){this.assertPosition(this.position+e.length-1),this.bytes.set(e,this.position),this.position+=e.length},pushUint8(e){this.assertPosition(this.position),this.bytes[this.position]=e,this.position++},pushUint16(e){this.assertPosition(this.position+1),this.dataView.setUint16(this.position,e),this.position+=2},pushUint24(e){this.assertPosition(this.position+2),this.dataView.setUint16(this.position,e>>8),this.dataView.setUint8(this.position+2,e&255),this.position+=3},pushUint32(e){this.assertPosition(this.position+3),this.dataView.setUint32(this.position,e),this.position+=4},readByte(){this.assertReadLimit(),this._touch();const e=this.inspectByte();return this.position++,e},readBytes(e,t){this.assertReadLimit(),this._touch();const n=this.inspectBytes(e);return this.position+=t??e,n},readUint8(){this.assertReadLimit(),this._touch();const e=this.inspectUint8();return this.position+=1,e},readUint16(){this.assertReadLimit(),this._touch();const e=this.inspectUint16();return this.position+=2,e},readUint24(){this.assertReadLimit(),this._touch();const e=this.inspectUint24();return this.position+=3,e},readUint32(){this.assertReadLimit(),this._touch();const e=this.inspectUint32();return this.position+=4,e},get remaining(){return this.bytes.length-this.position},setPosition(e){const t=this.position;return this.assertPosition(e),this.position=e,()=>this.position=t},_touch(){if(this.recursiveReadLimit===Number.POSITIVE_INFINITY)return;const e=this.getReadCount();this.positionReadCount.set(this.position,e+1),e>0&&this.recursiveReadCount++}};function Yr(e,{recursiveReadLimit:t=8192}={}){const n=Object.create(Qf);return n.bytes=e,n.dataView=new DataView(e.buffer,e.byteOffset,e.byteLength),n.positionReadCount=new Map,n.recursiveReadLimit=t,n}function ep(e,t={}){typeof t.size<"u"&&ve(e,{size:t.size});const n=ee(e,t);return Ce(n,t)}function tp(e,t={}){let n=e;if(typeof t.size<"u"&&(ve(n,{size:t.size}),n=Cn(n)),n.length>1||n[0]>1)throw new tf(n);return!!n[0]}function Se(e,t={}){typeof t.size<"u"&&ve(e,{size:t.size});const n=ee(e,t);return Ie(n,t)}function np(e,t={}){let n=e;return typeof t.size<"u"&&(ve(n,{size:t.size}),n=Cn(n,{dir:"right"})),new TextDecoder().decode(n)}function rp(e,t){const n=typeof t=="string"?Pe(t):t,r=Yr(n);if(X(n)===0&&e.length>0)throw new _r;if(X(t)&&X(t)<32)throw new Vl({data:typeof t=="string"?t:ee(t),params:e,size:X(t)});let o=0;const a=[];for(let u=0;u<e.length;++u){const c=e[u];r.setPosition(o);const[d,p]=Je(r,c,{staticPosition:0});o+=p,a.push(d)}return a}function Je(e,t,{staticPosition:n}){const r=Xr(t.type);if(r){const[o,a]=r;return ip(e,{...t,type:a},{length:o,staticPosition:n})}if(t.type==="tuple")return cp(e,t,{staticPosition:n});if(t.type==="address")return sp(e);if(t.type==="bool")return op(e);if(t.type.startsWith("bytes"))return ap(e,t,{staticPosition:n});if(t.type.startsWith("uint")||t.type.startsWith("int"))return up(e,t);if(t.type==="string")return dp(e,{staticPosition:n});throw new Zl(t.type,{docsPath:"/docs/contract/decodeAbiParameters"})}const Ns=32,pr=32;function sp(e){const t=e.readBytes(32);return[Qt(ee(Bo(t,-20))),32]}function ip(e,t,{length:n,staticPosition:r}){if(!n){const u=Se(e.readBytes(pr)),c=r+u,d=c+Ns;e.setPosition(c);const p=Se(e.readBytes(Ns)),f=Pt(t);let m=0;const y=[];for(let b=0;b<p;++b){e.setPosition(d+(f?b*32:m));const[x,T]=Je(e,t,{staticPosition:d});m+=T,y.push(x)}return e.setPosition(r+32),[y,32]}if(Pt(t)){const u=Se(e.readBytes(pr)),c=r+u,d=[];for(let p=0;p<n;++p){e.setPosition(c+p*32);const[f]=Je(e,t,{staticPosition:c});d.push(f)}return e.setPosition(r+32),[d,32]}let o=0;const a=[];for(let u=0;u<n;++u){const[c,d]=Je(e,t,{staticPosition:r+o});o+=d,a.push(c)}return[a,o]}function op(e){return[tp(e.readBytes(32),{size:32}),32]}function ap(e,t,{staticPosition:n}){const[r,o]=t.type.split("bytes");if(!o){const u=Se(e.readBytes(32));e.setPosition(n+u);const c=Se(e.readBytes(32));if(c===0)return e.setPosition(n+32),["0x",32];const d=e.readBytes(c);return e.setPosition(n+32),[ee(d),32]}return[ee(e.readBytes(Number.parseInt(o,10),32)),32]}function up(e,t){const n=t.type.startsWith("int"),r=Number.parseInt(t.type.split("int")[1]||"256",10),o=e.readBytes(32);return[r>48?ep(o,{signed:n}):Se(o,{signed:n}),32]}function cp(e,t,{staticPosition:n}){const r=t.components.length===0||t.components.some(({name:u})=>!u),o=r?[]:{};let a=0;if(Pt(t)){const u=Se(e.readBytes(pr)),c=n+u;for(let d=0;d<t.components.length;++d){const p=t.components[d];e.setPosition(c+a);const[f,m]=Je(e,p,{staticPosition:c});a+=m,o[r?d:p?.name]=f}return e.setPosition(n+32),[o,32]}for(let u=0;u<t.components.length;++u){const c=t.components[u],[d,p]=Je(e,c,{staticPosition:n});o[r?u:c?.name]=d,a+=p}return[o,a]}function dp(e,{staticPosition:t}){const n=Se(e.readBytes(32)),r=t+n;e.setPosition(r);const o=Se(e.readBytes(32));if(o===0)return e.setPosition(t+32),["",32];const a=e.readBytes(o,32),u=np(Cn(a));return e.setPosition(t+32),[u,32]}function Pt(e){const{type:t}=e;if(t==="string"||t==="bytes"||t.endsWith("[]"))return!0;if(t==="tuple")return e.components?.some(Pt);const n=Xr(e.type);return!!(n&&Pt({...e,type:n[1]}))}function lp(e){const{abi:t,data:n}=e,r=gn(n,0,4);if(r==="0x")throw new _r;const a=[...t||[],Kf,Yf].find(u=>u.type==="error"&&r===Kr(it(u)));if(!a)throw new mo(r,{docsPath:"/docs/contract/decodeErrorResult"});return{abiItem:a,args:"inputs"in a&&a.inputs&&a.inputs.length>0?rp(a.inputs,gn(n,4)):void 0,errorName:a.name}}const Ae=(e,t,n)=>JSON.stringify(e,(r,o)=>typeof o=="bigint"?o.toString():o,n);function No({abiItem:e,args:t,includeFunctionName:n=!0,includeName:r=!1}){if("name"in e&&"inputs"in e&&e.inputs)return`${n?e.name:""}(${e.inputs.map((o,a)=>`${r&&o.name?`${o.name}: `:""}${typeof t[a]=="object"?Ae(t[a]):t[a]}`).join(", ")})`}const fp={gwei:9,wei:18},pp={ether:-9,wei:9};function Lo(e,t){let n=e.toString();const r=n.startsWith("-");r&&(n=n.slice(1)),n=n.padStart(t,"0");let[o,a]=[n.slice(0,n.length-t),n.slice(n.length-t)];return a=a.replace(/(0+)$/,""),`${r?"-":""}${o||"0"}${a?`.${a}`:""}`}function zo(e,t="wei"){return Lo(e,fp[t])}function he(e,t="wei"){return Lo(e,pp[t])}class hp extends v{constructor({address:t}){super(`State for account "${t}" is set multiple times.`,{name:"AccountStateConflictError"})}}class yp extends v{constructor(){super("state and stateDiff are set on the same account.",{name:"StateAssignmentConflictError"})}}function Rn(e){const t=Object.entries(e).map(([r,o])=>o===void 0||o===!1?null:[r,o]).filter(Boolean),n=t.reduce((r,[o])=>Math.max(r,o.length),0);return t.map(([r,o])=>`  ${`${r}:`.padEnd(n+1)}  ${o}`).join(`
`)}class mp extends v{constructor({transaction:t}){super("Cannot infer a transaction type from provided transaction.",{metaMessages:["Provided Transaction:","{",Rn(t),"}","","To infer the type, either provide:","- a `type` to the Transaction, or","- an EIP-1559 Transaction with `maxFeePerGas`, or","- an EIP-2930 Transaction with `gasPrice` & `accessList`, or","- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or","- an EIP-7702 Transaction with `authorizationList`, or","- a Legacy Transaction with `gasPrice`"],name:"InvalidSerializableTransactionError"})}}class gp extends v{constructor(t,{account:n,docsPath:r,chain:o,data:a,gas:u,gasPrice:c,maxFeePerGas:d,maxPriorityFeePerGas:p,nonce:f,to:m,value:y}){const b=Rn({chain:o&&`${o?.name} (id: ${o?.id})`,from:n?.address,to:m,value:typeof y<"u"&&`${zo(y)} ${o?.nativeCurrency?.symbol||"ETH"}`,data:a,gas:u,gasPrice:typeof c<"u"&&`${he(c)} gwei`,maxFeePerGas:typeof d<"u"&&`${he(d)} gwei`,maxPriorityFeePerGas:typeof p<"u"&&`${he(p)} gwei`,nonce:f});super(t.shortMessage,{cause:t,docsPath:r,metaMessages:[...t.metaMessages?[...t.metaMessages," "]:[],"Request Arguments:",b].filter(Boolean),name:"TransactionExecutionError"}),Object.defineProperty(this,"cause",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.cause=t}}class _o extends v{constructor({blockHash:t,blockNumber:n,blockTag:r,hash:o,index:a}){let u="Transaction";r&&a!==void 0&&(u=`Transaction at block time "${r}" at index "${a}"`),t&&a!==void 0&&(u=`Transaction at block hash "${t}" at index "${a}"`),n&&a!==void 0&&(u=`Transaction at block number "${n}" at index "${a}"`),o&&(u=`Transaction with hash "${o}"`),super(`${u} could not be found.`,{name:"TransactionNotFoundError"})}}class Ho extends v{constructor({hash:t}){super(`Transaction receipt with hash "${t}" could not be found. The Transaction may not be processed on a block yet.`,{name:"TransactionReceiptNotFoundError"})}}class Vo extends v{constructor({receipt:t}){super(`Transaction with hash "${t.transactionHash}" reverted.`,{metaMessages:['The receipt marked the transaction as "reverted". This could mean that the function on the contract you are trying to call threw an error.'," ","You can attempt to extract the revert reason by:","- calling the `simulateContract` or `simulateCalls` Action with the `abi` and `functionName` of the contract","- using the `call` Action with raw `data`"],name:"TransactionReceiptRevertedError"}),Object.defineProperty(this,"receipt",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.receipt=t}}class bp extends v{constructor({hash:t}){super(`Timed out while waiting for transaction with hash "${t}" to be confirmed.`,{name:"WaitForTransactionReceiptTimeoutError"})}}const wp=e=>e,Go=e=>e;class xp extends v{constructor(t,{abi:n,args:r,contractAddress:o,docsPath:a,functionName:u,sender:c}){const d=Mo({abi:n,args:r,name:u}),p=d?No({abiItem:d,args:r,includeFunctionName:!1,includeName:!1}):void 0,f=d?it(d,{includeName:!0}):void 0,m=Rn({address:o&&wp(o),function:f,args:p&&p!=="()"&&`${[...Array(u?.length??0).keys()].map(()=>" ").join("")}${p}`,sender:c});super(t.shortMessage||`An unknown error occurred while executing the contract function "${u}".`,{cause:t,docsPath:a,metaMessages:[...t.metaMessages?[...t.metaMessages," "]:[],m&&"Contract Call:",m].filter(Boolean),name:"ContractFunctionExecutionError"}),Object.defineProperty(this,"abi",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"args",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"cause",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"contractAddress",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"formattedArgs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"functionName",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"sender",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.abi=n,this.args=r,this.cause=t,this.contractAddress=o,this.functionName=u,this.sender=c}}class Ap extends v{constructor({abi:t,data:n,functionName:r,message:o}){let a,u,c,d;if(n&&n!=="0x")try{u=lp({abi:t,data:n});const{abiItem:f,errorName:m,args:y}=u;if(m==="Error")d=y[0];else if(m==="Panic"){const[b]=y;d=Xf[b]}else{const b=f?it(f,{includeName:!0}):void 0,x=f&&y?No({abiItem:f,args:y,includeFunctionName:!1,includeName:!1}):void 0;c=[b?`Error: ${b}`:"",x&&x!=="()"?`       ${[...Array(m?.length??0).keys()].map(()=>" ").join("")}${x}`:""]}}catch(f){a=f}else o&&(d=o);let p;a instanceof mo&&(p=a.signature,c=[`Unable to decode signature "${p}" as it was not found on the provided ABI.`,"Make sure you are using the correct ABI and that the error exists on it.",`You can look up the decoded signature here: https://openchain.xyz/signatures?query=${p}.`]),super(d&&d!=="execution reverted"||p?[`The contract function "${r}" reverted with the following ${p?"signature":"reason"}:`,d||p].join(`
`):`The contract function "${r}" reverted.`,{cause:a,metaMessages:c,name:"ContractFunctionRevertedError"}),Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"raw",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"reason",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"signature",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.data=u,this.raw=n,this.reason=d,this.signature=p}}class vp extends v{constructor({functionName:t}){super(`The contract function "${t}" returned no data ("0x").`,{metaMessages:["This could be due to any of the following:",`  - The contract does not have the function "${t}",`,"  - The parameters passed to the contract function may be invalid, or","  - The address is not a contract."],name:"ContractFunctionZeroDataError"})}}class qp extends v{constructor({data:t,message:n}){super(n||"",{name:"RawContractError"}),Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:3}),Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.data=t}}class jo extends v{constructor({body:t,cause:n,details:r,headers:o,status:a,url:u}){super("HTTP request failed.",{cause:n,details:r,metaMessages:[a&&`Status: ${a}`,`URL: ${Go(u)}`,t&&`Request body: ${Ae(t)}`].filter(Boolean),name:"HttpRequestError"}),Object.defineProperty(this,"body",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"headers",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"status",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"url",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.body=t,this.headers=o,this.status=a,this.url=u}}class Wo extends v{constructor({body:t,error:n,url:r}){super("RPC Request failed.",{cause:n,details:n.message,metaMessages:[`URL: ${Go(r)}`,`Request body: ${Ae(t)}`],name:"RpcRequestError"}),Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"url",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.code=n.code,this.data=n.data,this.url=r}}const Tp=-1;class ne extends v{constructor(t,{code:n,docsPath:r,metaMessages:o,name:a,shortMessage:u}){super(u,{cause:t,docsPath:r,metaMessages:o||t?.metaMessages,name:a||"RpcError"}),Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.name=a||t.name,this.code=t instanceof Wo?t.code:n??Tp}}class ae extends ne{constructor(t,n){super(t,n),Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.data=n.data}}class kt extends ne{constructor(t){super(t,{code:kt.code,name:"ParseRpcError",shortMessage:"Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."})}}Object.defineProperty(kt,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32700});class Rt extends ne{constructor(t){super(t,{code:Rt.code,name:"InvalidRequestRpcError",shortMessage:"JSON is not a valid request object."})}}Object.defineProperty(Rt,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32600});class Ut extends ne{constructor(t,{method:n}={}){super(t,{code:Ut.code,name:"MethodNotFoundRpcError",shortMessage:`The method${n?` "${n}"`:""} does not exist / is not available.`})}}Object.defineProperty(Ut,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32601});class Bt extends ne{constructor(t){super(t,{code:Bt.code,name:"InvalidParamsRpcError",shortMessage:["Invalid parameters were provided to the RPC method.","Double check you have provided the correct parameters."].join(`
`)})}}Object.defineProperty(Bt,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32602});class Ke extends ne{constructor(t){super(t,{code:Ke.code,name:"InternalRpcError",shortMessage:"An internal error was received."})}}Object.defineProperty(Ke,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32603});class ot extends ne{constructor(t){super(t,{code:ot.code,name:"InvalidInputRpcError",shortMessage:["Missing or invalid parameters.","Double check you have provided the correct parameters."].join(`
`)})}}Object.defineProperty(ot,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32e3});class $t extends ne{constructor(t){super(t,{code:$t.code,name:"ResourceNotFoundRpcError",shortMessage:"Requested resource not found."}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ResourceNotFoundRpcError"})}}Object.defineProperty($t,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32001});class Dt extends ne{constructor(t){super(t,{code:Dt.code,name:"ResourceUnavailableRpcError",shortMessage:"Requested resource not available."})}}Object.defineProperty(Dt,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32002});class Mt extends ne{constructor(t){super(t,{code:Mt.code,name:"TransactionRejectedRpcError",shortMessage:"Transaction creation failed."})}}Object.defineProperty(Mt,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32003});class Ve extends ne{constructor(t,{method:n}={}){super(t,{code:Ve.code,name:"MethodNotSupportedRpcError",shortMessage:`Method${n?` "${n}"`:""} is not supported.`})}}Object.defineProperty(Ve,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32004});class at extends ne{constructor(t){super(t,{code:at.code,name:"LimitExceededRpcError",shortMessage:"Request exceeds defined limit."})}}Object.defineProperty(at,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32005});class Ft extends ne{constructor(t){super(t,{code:Ft.code,name:"JsonRpcVersionUnsupportedError",shortMessage:"Version of JSON-RPC protocol is not supported."})}}Object.defineProperty(Ft,"code",{enumerable:!0,configurable:!0,writable:!0,value:-32006});class Qe extends ae{constructor(t){super(t,{code:Qe.code,name:"UserRejectedRequestError",shortMessage:"User rejected the request."})}}Object.defineProperty(Qe,"code",{enumerable:!0,configurable:!0,writable:!0,value:4001});class Ot extends ae{constructor(t){super(t,{code:Ot.code,name:"UnauthorizedProviderError",shortMessage:"The requested method and/or account has not been authorized by the user."})}}Object.defineProperty(Ot,"code",{enumerable:!0,configurable:!0,writable:!0,value:4100});class Nt extends ae{constructor(t,{method:n}={}){super(t,{code:Nt.code,name:"UnsupportedProviderMethodError",shortMessage:`The Provider does not support the requested method${n?` " ${n}"`:""}.`})}}Object.defineProperty(Nt,"code",{enumerable:!0,configurable:!0,writable:!0,value:4200});class Lt extends ae{constructor(t){super(t,{code:Lt.code,name:"ProviderDisconnectedError",shortMessage:"The Provider is disconnected from all chains."})}}Object.defineProperty(Lt,"code",{enumerable:!0,configurable:!0,writable:!0,value:4900});class zt extends ae{constructor(t){super(t,{code:zt.code,name:"ChainDisconnectedError",shortMessage:"The Provider is not connected to the requested chain."})}}Object.defineProperty(zt,"code",{enumerable:!0,configurable:!0,writable:!0,value:4901});class _t extends ae{constructor(t){super(t,{code:_t.code,name:"SwitchChainError",shortMessage:"An error occurred when attempting to switch chain."})}}Object.defineProperty(_t,"code",{enumerable:!0,configurable:!0,writable:!0,value:4902});class ut extends ae{constructor(t){super(t,{code:ut.code,name:"UnsupportedNonOptionalCapabilityError",shortMessage:"This Wallet does not support a capability that was not marked as optional."})}}Object.defineProperty(ut,"code",{enumerable:!0,configurable:!0,writable:!0,value:5700});class Ht extends ae{constructor(t){super(t,{code:Ht.code,name:"UnsupportedChainIdError",shortMessage:"This Wallet does not support the requested chain ID."})}}Object.defineProperty(Ht,"code",{enumerable:!0,configurable:!0,writable:!0,value:5710});class Vt extends ae{constructor(t){super(t,{code:Vt.code,name:"DuplicateIdError",shortMessage:"There is already a bundle submitted with this ID."})}}Object.defineProperty(Vt,"code",{enumerable:!0,configurable:!0,writable:!0,value:5720});class Gt extends ae{constructor(t){super(t,{code:Gt.code,name:"UnknownBundleIdError",shortMessage:"This bundle id is unknown / has not been submitted"})}}Object.defineProperty(Gt,"code",{enumerable:!0,configurable:!0,writable:!0,value:5730});class jt extends ae{constructor(t){super(t,{code:jt.code,name:"BundleTooLargeError",shortMessage:"The call bundle is too large for the Wallet to process."})}}Object.defineProperty(jt,"code",{enumerable:!0,configurable:!0,writable:!0,value:5740});class Wt extends ae{constructor(t){super(t,{code:Wt.code,name:"AtomicReadyWalletRejectedUpgradeError",shortMessage:"The Wallet can support atomicity after an upgrade, but the user rejected the upgrade."})}}Object.defineProperty(Wt,"code",{enumerable:!0,configurable:!0,writable:!0,value:5750});class ct extends ae{constructor(t){super(t,{code:ct.code,name:"AtomicityNotSupportedError",shortMessage:"The wallet does not support atomic execution but the request requires it."})}}Object.defineProperty(ct,"code",{enumerable:!0,configurable:!0,writable:!0,value:5760});class Ep extends ne{constructor(t){super(t,{name:"UnknownRpcError",shortMessage:"An unknown RPC error occurred."})}}const Sp=3;function Cp(e,{abi:t,address:n,args:r,docsPath:o,functionName:a,sender:u}){const c=e instanceof qp?e:e instanceof v?e.walk(x=>"data"in x)||e.walk():{},{code:d,data:p,details:f,message:m,shortMessage:y}=c,b=e instanceof _r?new vp({functionName:a}):[Sp,Ke.code].includes(d)&&(p||f||m||y)||d===ot.code&&f==="execution reverted"&&p?new Ap({abi:t,data:typeof p=="object"?p.data:p,functionName:a,message:c instanceof Wo?f:y??m}):e;return new xp(b,{abi:t,args:r,contractAddress:n,docsPath:o,functionName:a,sender:u})}function Ip(e){const t=Pn(`0x${e.substring(4)}`).substring(26);return Qt(`0x${t}`)}const Pp="modulepreload",kp=function(e){return"/"+e},Ls={},Rp=function(t,n,r){let o=Promise.resolve();if(n&&n.length>0){let p=function(f){return Promise.all(f.map(m=>Promise.resolve(m).then(y=>({status:"fulfilled",value:y}),y=>({status:"rejected",reason:y}))))};var u=p;document.getElementsByTagName("link");const c=document.querySelector("meta[property=csp-nonce]"),d=c?.nonce||c?.getAttribute("nonce");o=p(n.map(f=>{if(f=kp(f),f in Ls)return;Ls[f]=!0;const m=f.endsWith(".css"),y=m?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${f}"]${y}`))return;const b=document.createElement("link");if(b.rel=m?"stylesheet":Pp,m||(b.as="script"),b.crossOrigin="",b.href=f,d&&b.setAttribute("nonce",d),document.head.appendChild(b),m)return new Promise((x,T)=>{b.addEventListener("load",x),b.addEventListener("error",()=>T(new Error(`Unable to preload CSS for ${f}`)))})}))}function a(c){const d=new Event("vite:preloadError",{cancelable:!0});if(d.payload=c,window.dispatchEvent(d),!d.defaultPrevented)throw c}return o.then(c=>{for(const d of c||[])d.status==="rejected"&&a(d.reason);return t().catch(a)})};async function Up({hash:e,signature:t}){const n=Fe(e)?e:yn(e),{secp256k1:r}=await Rp(async()=>{const{secp256k1:u}=await import("./secp256k1-BUXgMORJ.js");return{secp256k1:u}},[]);return`0x${(()=>{if(typeof t=="object"&&"r"in t&&"s"in t){const{r:p,s:f,v:m,yParity:y}=t,b=Number(y??m),x=zs(b);return new r.Signature(Ce(p),Ce(f)).addRecoveryBit(x)}const u=Fe(t)?t:yn(t);if(X(u)!==65)throw new Error("invalid signature length");const c=Ie(`0x${u.slice(130)}`),d=zs(c);return r.Signature.fromCompact(u.substring(2,130)).addRecoveryBit(d)})().recoverPublicKey(n.substring(2)).toHex(!1)}`}function zs(e){if(e===0||e===1)return e;if(e===27)return 0;if(e===28)return 1;throw new Error("Invalid yParityOrV value")}async function Bp({hash:e,signature:t}){return Ip(await Up({hash:e,signature:t}))}function $p(e,t="hex"){const n=Xo(e),r=Yr(new Uint8Array(n.length));return n.encode(r),t==="hex"?ee(r.bytes):r.bytes}function Xo(e){return Array.isArray(e)?Dp(e.map(t=>Xo(t))):Mp(e)}function Dp(e){const t=e.reduce((o,a)=>o+a.length,0),n=Ko(t);return{length:t<=55?1+t:1+n+t,encode(o){t<=55?o.pushByte(192+t):(o.pushByte(247+n),n===1?o.pushUint8(t):n===2?o.pushUint16(t):n===3?o.pushUint24(t):o.pushUint32(t));for(const{encode:a}of e)a(o)}}}function Mp(e){const t=typeof e=="string"?Pe(e):e,n=Ko(t.length);return{length:t.length===1&&t[0]<128?1:t.length<=55?1+t.length:1+n+t.length,encode(o){t.length===1&&t[0]<128?o.pushBytes(t):t.length<=55?(o.pushByte(128+t.length),o.pushBytes(t)):(o.pushByte(183+n),n===1?o.pushUint8(t.length):n===2?o.pushUint16(t.length):n===3?o.pushUint24(t.length):o.pushUint32(t.length),o.pushBytes(t))}}}function Ko(e){if(e<2**8)return 1;if(e<2**16)return 2;if(e<2**24)return 3;if(e<2**32)return 4;throw new v("Length is too large.")}function Fp(e){const{chainId:t,nonce:n,to:r}=e,o=e.contractAddress??e.address,a=Pn(kn(["0x05",$p([t?$(t):"0x",o,n?$(n):"0x"])]));return r==="bytes"?Pe(a):a}async function Zr(e){const{authorization:t,signature:n}=e;return Bp({hash:Fp(t),signature:n??t})}class Op extends v{constructor(t,{account:n,docsPath:r,chain:o,data:a,gas:u,gasPrice:c,maxFeePerGas:d,maxPriorityFeePerGas:p,nonce:f,to:m,value:y}){const b=Rn({from:n?.address,to:m,value:typeof y<"u"&&`${zo(y)} ${o?.nativeCurrency?.symbol||"ETH"}`,data:a,gas:u,gasPrice:typeof c<"u"&&`${he(c)} gwei`,maxFeePerGas:typeof d<"u"&&`${he(d)} gwei`,maxPriorityFeePerGas:typeof p<"u"&&`${he(p)} gwei`,nonce:f});super(t.shortMessage,{cause:t,docsPath:r,metaMessages:[...t.metaMessages?[...t.metaMessages," "]:[],"Estimate Gas Arguments:",b].filter(Boolean),name:"EstimateGasExecutionError"}),Object.defineProperty(this,"cause",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.cause=t}}class Ze extends v{constructor({cause:t,message:n}={}){const r=n?.replace("execution reverted: ","")?.replace("execution reverted","");super(`Execution reverted ${r?`with reason: ${r}`:"for an unknown reason"}.`,{cause:t,name:"ExecutionRevertedError"})}}Object.defineProperty(Ze,"code",{enumerable:!0,configurable:!0,writable:!0,value:3});Object.defineProperty(Ze,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/execution reverted/});class bn extends v{constructor({cause:t,maxFeePerGas:n}={}){super(`The fee cap (\`maxFeePerGas\`${n?` = ${he(n)} gwei`:""}) cannot be higher than the maximum allowed value (2^256-1).`,{cause:t,name:"FeeCapTooHighError"})}}Object.defineProperty(bn,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/});class hr extends v{constructor({cause:t,maxFeePerGas:n}={}){super(`The fee cap (\`maxFeePerGas\`${n?` = ${he(n)}`:""} gwei) cannot be lower than the block base fee.`,{cause:t,name:"FeeCapTooLowError"})}}Object.defineProperty(hr,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/});class yr extends v{constructor({cause:t,nonce:n}={}){super(`Nonce provided for the transaction ${n?`(${n}) `:""}is higher than the next one expected.`,{cause:t,name:"NonceTooHighError"})}}Object.defineProperty(yr,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/nonce too high/});class mr extends v{constructor({cause:t,nonce:n}={}){super([`Nonce provided for the transaction ${n?`(${n}) `:""}is lower than the current nonce of the account.`,"Try increasing the nonce or find the latest nonce with `getTransactionCount`."].join(`
`),{cause:t,name:"NonceTooLowError"})}}Object.defineProperty(mr,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/nonce too low|transaction already imported|already known/});class gr extends v{constructor({cause:t,nonce:n}={}){super(`Nonce provided for the transaction ${n?`(${n}) `:""}exceeds the maximum allowed nonce.`,{cause:t,name:"NonceMaxValueError"})}}Object.defineProperty(gr,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/nonce has max value/});class br extends v{constructor({cause:t}={}){super(["The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."].join(`
`),{cause:t,metaMessages:["This error could arise when the account does not have enough funds to:"," - pay for the total gas fee,"," - pay for the value to send."," ","The cost of the transaction is calculated as `gas * gas fee + value`, where:"," - `gas` is the amount of gas needed for transaction to execute,"," - `gas fee` is the gas fee,"," - `value` is the amount of ether to send to the recipient."],name:"InsufficientFundsError"})}}Object.defineProperty(br,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/insufficient funds|exceeds transaction sender account balance/});class wr extends v{constructor({cause:t,gas:n}={}){super(`The amount of gas ${n?`(${n}) `:""}provided for the transaction exceeds the limit allowed for the block.`,{cause:t,name:"IntrinsicGasTooHighError"})}}Object.defineProperty(wr,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/intrinsic gas too high|gas limit reached/});class xr extends v{constructor({cause:t,gas:n}={}){super(`The amount of gas ${n?`(${n}) `:""}provided for the transaction is too low.`,{cause:t,name:"IntrinsicGasTooLowError"})}}Object.defineProperty(xr,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/intrinsic gas too low/});class Ar extends v{constructor({cause:t}){super("The transaction type is not supported for this chain.",{cause:t,name:"TransactionTypeNotSupportedError"})}}Object.defineProperty(Ar,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/transaction type not valid/});class wn extends v{constructor({cause:t,maxPriorityFeePerGas:n,maxFeePerGas:r}={}){super([`The provided tip (\`maxPriorityFeePerGas\`${n?` = ${he(n)} gwei`:""}) cannot be higher than the fee cap (\`maxFeePerGas\`${r?` = ${he(r)} gwei`:""}).`].join(`
`),{cause:t,name:"TipAboveFeeCapError"})}}Object.defineProperty(wn,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/max priority fee per gas higher than max fee per gas|tip higher than fee cap/});class Jr extends v{constructor({cause:t}){super(`An error occurred while executing: ${t?.shortMessage}`,{cause:t,name:"UnknownNodeError"})}}function Yo(e,t){const n=(e.details||"").toLowerCase(),r=e instanceof v?e.walk(o=>o?.code===Ze.code):e;return r instanceof v?new Ze({cause:e,message:r.details}):Ze.nodeMessage.test(n)?new Ze({cause:e,message:e.details}):bn.nodeMessage.test(n)?new bn({cause:e,maxFeePerGas:t?.maxFeePerGas}):hr.nodeMessage.test(n)?new hr({cause:e,maxFeePerGas:t?.maxFeePerGas}):yr.nodeMessage.test(n)?new yr({cause:e,nonce:t?.nonce}):mr.nodeMessage.test(n)?new mr({cause:e,nonce:t?.nonce}):gr.nodeMessage.test(n)?new gr({cause:e,nonce:t?.nonce}):br.nodeMessage.test(n)?new br({cause:e}):wr.nodeMessage.test(n)?new wr({cause:e,gas:t?.gas}):xr.nodeMessage.test(n)?new xr({cause:e,gas:t?.gas}):Ar.nodeMessage.test(n)?new Ar({cause:e}):wn.nodeMessage.test(n)?new wn({cause:e,maxFeePerGas:t?.maxFeePerGas,maxPriorityFeePerGas:t?.maxPriorityFeePerGas}):new Jr({cause:e})}function Np(e,{docsPath:t,...n}){const r=(()=>{const o=Yo(e,n);return o instanceof Jr?e:o})();return new Op(r,{docsPath:t,...n})}function Un(e,{format:t}){if(!t)return{};const n={};function r(a){const u=Object.keys(a);for(const c of u)c in e&&(n[c]=e[c]),a[c]&&typeof a[c]=="object"&&!Array.isArray(a[c])&&r(a[c])}const o=t(e||{});return r(o),n}const Lp={legacy:"0x0",eip2930:"0x1",eip1559:"0x2",eip4844:"0x3",eip7702:"0x4"};function en(e,t){const n={};return typeof e.authorizationList<"u"&&(n.authorizationList=zp(e.authorizationList)),typeof e.accessList<"u"&&(n.accessList=e.accessList),typeof e.blobVersionedHashes<"u"&&(n.blobVersionedHashes=e.blobVersionedHashes),typeof e.blobs<"u"&&(typeof e.blobs[0]!="string"?n.blobs=e.blobs.map(r=>ee(r)):n.blobs=e.blobs),typeof e.data<"u"&&(n.data=e.data),e.account&&(n.from=e.account.address),typeof e.from<"u"&&(n.from=e.from),typeof e.gas<"u"&&(n.gas=$(e.gas)),typeof e.gasPrice<"u"&&(n.gasPrice=$(e.gasPrice)),typeof e.maxFeePerBlobGas<"u"&&(n.maxFeePerBlobGas=$(e.maxFeePerBlobGas)),typeof e.maxFeePerGas<"u"&&(n.maxFeePerGas=$(e.maxFeePerGas)),typeof e.maxPriorityFeePerGas<"u"&&(n.maxPriorityFeePerGas=$(e.maxPriorityFeePerGas)),typeof e.nonce<"u"&&(n.nonce=$(e.nonce)),typeof e.to<"u"&&(n.to=e.to),typeof e.type<"u"&&(n.type=Lp[e.type]),typeof e.value<"u"&&(n.value=$(e.value)),n}function zp(e){return e.map(t=>({address:t.address,r:t.r?$(BigInt(t.r)):t.r,s:t.s?$(BigInt(t.s)):t.s,chainId:$(t.chainId),nonce:$(t.nonce),...typeof t.yParity<"u"?{yParity:$(t.yParity)}:{},...typeof t.v<"u"&&typeof t.yParity>"u"?{v:$(t.v)}:{}}))}function _s(e){if(!(!e||e.length===0))return e.reduce((t,{slot:n,value:r})=>{if(n.length!==66)throw new ks({size:n.length,targetSize:66,type:"hex"});if(r.length!==66)throw new ks({size:r.length,targetSize:66,type:"hex"});return t[n]=r,t},{})}function _p(e){const{balance:t,nonce:n,state:r,stateDiff:o,code:a}=e,u={};if(a!==void 0&&(u.code=a),t!==void 0&&(u.balance=$(t)),n!==void 0&&(u.nonce=$(n)),r!==void 0&&(u.state=_s(r)),o!==void 0){if(u.state)throw new yp;u.stateDiff=_s(o)}return u}function Hp(e){if(!e)return;const t={};for(const{address:n,...r}of e){if(!ie(n,{strict:!1}))throw new Oe({address:n});if(t[n])throw new hp({address:n});t[n]=_p(r)}return t}const Vp=2n**256n-1n;function pt(e){const{account:t,maxFeePerGas:n,maxPriorityFeePerGas:r,to:o}=e,a=t?J(t):void 0;if(a&&!ie(a.address))throw new Oe({address:a.address});if(o&&!ie(o))throw new Oe({address:o});if(n&&n>Vp)throw new bn({maxFeePerGas:n});if(r&&n&&r>n)throw new wn({maxFeePerGas:n,maxPriorityFeePerGas:r})}class Zo extends v{constructor(){super("`baseFeeMultiplier` must be greater than 1.",{name:"BaseFeeScalarError"})}}class Qr extends v{constructor(){super("Chain does not support EIP-1559 fees.",{name:"Eip1559FeesNotSupportedError"})}}class Gp extends v{constructor({maxPriorityFeePerGas:t}){super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${he(t)} gwei).`,{name:"MaxFeePerGasTooLowError"})}}class Jo extends v{constructor({blockHash:t,blockNumber:n}){let r="Block";t&&(r=`Block at hash "${t}"`),n&&(r=`Block at number "${n}"`),super(`${r} could not be found.`,{name:"BlockNotFoundError"})}}const Qo={"0x0":"legacy","0x1":"eip2930","0x2":"eip1559","0x3":"eip4844","0x4":"eip7702"};function es(e,t){const n={...e,blockHash:e.blockHash?e.blockHash:null,blockNumber:e.blockNumber?BigInt(e.blockNumber):null,chainId:e.chainId?Ie(e.chainId):void 0,gas:e.gas?BigInt(e.gas):void 0,gasPrice:e.gasPrice?BigInt(e.gasPrice):void 0,maxFeePerBlobGas:e.maxFeePerBlobGas?BigInt(e.maxFeePerBlobGas):void 0,maxFeePerGas:e.maxFeePerGas?BigInt(e.maxFeePerGas):void 0,maxPriorityFeePerGas:e.maxPriorityFeePerGas?BigInt(e.maxPriorityFeePerGas):void 0,nonce:e.nonce?Ie(e.nonce):void 0,to:e.to?e.to:null,transactionIndex:e.transactionIndex?Number(e.transactionIndex):null,type:e.type?Qo[e.type]:void 0,typeHex:e.type?e.type:void 0,value:e.value?BigInt(e.value):void 0,v:e.v?BigInt(e.v):void 0};return e.authorizationList&&(n.authorizationList=jp(e.authorizationList)),n.yParity=(()=>{if(e.yParity)return Number(e.yParity);if(typeof n.v=="bigint"){if(n.v===0n||n.v===27n)return 0;if(n.v===1n||n.v===28n)return 1;if(n.v>=35n)return n.v%2n===0n?1:0}})(),n.type==="legacy"&&(delete n.accessList,delete n.maxFeePerBlobGas,delete n.maxFeePerGas,delete n.maxPriorityFeePerGas,delete n.yParity),n.type==="eip2930"&&(delete n.maxFeePerBlobGas,delete n.maxFeePerGas,delete n.maxPriorityFeePerGas),n.type==="eip1559"&&delete n.maxFeePerBlobGas,n}function jp(e){return e.map(t=>({address:t.address,chainId:Number(t.chainId),nonce:Number(t.nonce),r:t.r,s:t.s,yParity:Number(t.yParity)}))}function Wp(e,t){const n=(e.transactions??[]).map(r=>typeof r=="string"?r:es(r));return{...e,baseFeePerGas:e.baseFeePerGas?BigInt(e.baseFeePerGas):null,blobGasUsed:e.blobGasUsed?BigInt(e.blobGasUsed):void 0,difficulty:e.difficulty?BigInt(e.difficulty):void 0,excessBlobGas:e.excessBlobGas?BigInt(e.excessBlobGas):void 0,gasLimit:e.gasLimit?BigInt(e.gasLimit):void 0,gasUsed:e.gasUsed?BigInt(e.gasUsed):void 0,hash:e.hash?e.hash:null,logsBloom:e.logsBloom?e.logsBloom:null,nonce:e.nonce?e.nonce:null,number:e.number?BigInt(e.number):null,size:e.size?BigInt(e.size):void 0,timestamp:e.timestamp?BigInt(e.timestamp):void 0,transactions:n,totalDifficulty:e.totalDifficulty?BigInt(e.totalDifficulty):null}}async function dt(e,{blockHash:t,blockNumber:n,blockTag:r=e.experimental_blockTag??"latest",includeTransactions:o}={}){const a=o??!1,u=n!==void 0?$(n):void 0;let c=null;if(t?c=await e.request({method:"eth_getBlockByHash",params:[t,a]},{dedupe:!0}):c=await e.request({method:"eth_getBlockByNumber",params:[u||r,a]},{dedupe:!!u}),!c)throw new Jo({blockHash:t,blockNumber:n});return(e.chain?.formatters?.block?.format||Wp)(c,"getBlock")}async function ea(e){const t=await e.request({method:"eth_gasPrice"});return BigInt(t)}async function Xp(e,t){const{block:n,chain:r=e.chain,request:o}=t||{};try{const a=r?.fees?.maxPriorityFeePerGas??r?.fees?.defaultPriorityFee;if(typeof a=="function"){const c=n||await O(e,dt,"getBlock")({}),d=await a({block:c,client:e,request:o});if(d===null)throw new Error;return d}if(typeof a<"u")return a;const u=await e.request({method:"eth_maxPriorityFeePerGas"});return Ce(u)}catch{const[a,u]=await Promise.all([n?Promise.resolve(n):O(e,dt,"getBlock")({}),O(e,ea,"getGasPrice")({})]);if(typeof a.baseFeePerGas!="bigint")throw new Qr;const c=u-a.baseFeePerGas;return c<0n?0n:c}}async function Hs(e,t){const{block:n,chain:r=e.chain,request:o,type:a="eip1559"}=t||{},u=await(async()=>typeof r?.fees?.baseFeeMultiplier=="function"?r.fees.baseFeeMultiplier({block:n,client:e,request:o}):r?.fees?.baseFeeMultiplier??1.2)();if(u<1)throw new Zo;const d=10**(u.toString().split(".")[1]?.length??0),p=y=>y*BigInt(Math.ceil(u*d))/BigInt(d),f=n||await O(e,dt,"getBlock")({});if(typeof r?.fees?.estimateFeesPerGas=="function"){const y=await r.fees.estimateFeesPerGas({block:n,client:e,multiply:p,request:o,type:a});if(y!==null)return y}if(a==="eip1559"){if(typeof f.baseFeePerGas!="bigint")throw new Qr;const y=typeof o?.maxPriorityFeePerGas=="bigint"?o.maxPriorityFeePerGas:await Xp(e,{block:f,chain:r,request:o}),b=p(f.baseFeePerGas);return{maxFeePerGas:o?.maxFeePerGas??b+y,maxPriorityFeePerGas:y}}return{gasPrice:o?.gasPrice??p(await O(e,ea,"getGasPrice")({}))}}async function ta(e,{address:t,blockTag:n="latest",blockNumber:r}){const o=await e.request({method:"eth_getTransactionCount",params:[t,typeof r=="bigint"?$(r):n]},{dedupe:!!r});return Ie(o)}function na(e){const{kzg:t}=e,n=e.to??(typeof e.blobs[0]=="string"?"hex":"bytes"),r=typeof e.blobs[0]=="string"?e.blobs.map(a=>Pe(a)):e.blobs,o=[];for(const a of r)o.push(Uint8Array.from(t.blobToKzgCommitment(a)));return n==="bytes"?o:o.map(a=>ee(a))}function ra(e){const{kzg:t}=e,n=e.to??(typeof e.blobs[0]=="string"?"hex":"bytes"),r=typeof e.blobs[0]=="string"?e.blobs.map(u=>Pe(u)):e.blobs,o=typeof e.commitments[0]=="string"?e.commitments.map(u=>Pe(u)):e.commitments,a=[];for(let u=0;u<r.length;u++){const c=r[u],d=o[u];a.push(Uint8Array.from(t.computeBlobKzgProof(c,d)))}return n==="bytes"?a:a.map(u=>ee(u))}function Kp(e,t,n,r){if(typeof e.setBigUint64=="function")return e.setBigUint64(t,n,r);const o=BigInt(32),a=BigInt(4294967295),u=Number(n>>o&a),c=Number(n&a),d=r?4:0,p=r?0:4;e.setUint32(t+d,u,r),e.setUint32(t+p,c,r)}function Yp(e,t,n){return e&t^~e&n}function Zp(e,t,n){return e&t^e&n^t&n}class Jp extends qo{constructor(t,n,r,o){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=t,this.outputLen=n,this.padOffset=r,this.isLE=o,this.buffer=new Uint8Array(t),this.view=Vn(this.buffer)}update(t){mn(this),t=Vr(t),Ct(t);const{view:n,buffer:r,blockLen:o}=this,a=t.length;for(let u=0;u<a;){const c=Math.min(o-this.pos,a-u);if(c===o){const d=Vn(t);for(;o<=a-u;u+=o)this.process(d,u);continue}r.set(t.subarray(u,u+c),this.pos),this.pos+=c,u+=c,this.pos===o&&(this.process(n,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){mn(this),vo(t,this),this.finished=!0;const{buffer:n,view:r,blockLen:o,isLE:a}=this;let{pos:u}=this;n[u++]=128,It(this.buffer.subarray(u)),this.padOffset>o-u&&(this.process(r,0),u=0);for(let m=u;m<o;m++)n[m]=0;Kp(r,o-8,BigInt(this.length*8),a),this.process(r,0);const c=Vn(t),d=this.outputLen;if(d%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const p=d/4,f=this.get();if(p>f.length)throw new Error("_sha2: outputLen bigger than state");for(let m=0;m<p;m++)c.setUint32(4*m,f[m],a)}digest(){const{buffer:t,outputLen:n}=this;this.digestInto(t);const r=t.slice(0,n);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:n,buffer:r,length:o,finished:a,destroyed:u,pos:c}=this;return t.destroyed=u,t.finished=a,t.length=o,t.pos=c,o%n&&t.buffer.set(r),t}clone(){return this._cloneInto()}}const ke=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Qp=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Re=new Uint32Array(64);class eh extends Jp{constructor(t=32){super(64,t,8,!1),this.A=ke[0]|0,this.B=ke[1]|0,this.C=ke[2]|0,this.D=ke[3]|0,this.E=ke[4]|0,this.F=ke[5]|0,this.G=ke[6]|0,this.H=ke[7]|0}get(){const{A:t,B:n,C:r,D:o,E:a,F:u,G:c,H:d}=this;return[t,n,r,o,a,u,c,d]}set(t,n,r,o,a,u,c,d){this.A=t|0,this.B=n|0,this.C=r|0,this.D=o|0,this.E=a|0,this.F=u|0,this.G=c|0,this.H=d|0}process(t,n){for(let m=0;m<16;m++,n+=4)Re[m]=t.getUint32(n,!1);for(let m=16;m<64;m++){const y=Re[m-15],b=Re[m-2],x=be(y,7)^be(y,18)^y>>>3,T=be(b,17)^be(b,19)^b>>>10;Re[m]=T+Re[m-7]+x+Re[m-16]|0}let{A:r,B:o,C:a,D:u,E:c,F:d,G:p,H:f}=this;for(let m=0;m<64;m++){const y=be(c,6)^be(c,11)^be(c,25),b=f+y+Yp(c,d,p)+Qp[m]+Re[m]|0,T=(be(r,2)^be(r,13)^be(r,22))+Zp(r,o,a)|0;f=p,p=d,d=c,c=u+b|0,u=a,a=o,o=r,r=b+T|0}r=r+this.A|0,o=o+this.B|0,a=a+this.C|0,u=u+this.D|0,c=c+this.E|0,d=d+this.F|0,p=p+this.G|0,f=f+this.H|0,this.set(r,o,a,u,c,d,p,f)}roundClean(){It(Re)}destroy(){this.set(0,0,0,0,0,0,0,0),It(this.buffer)}}const th=To(()=>new eh),nh=th;function rh(e,t){return nh(Fe(e,{strict:!1})?Hr(e):e)}function sh(e){const{commitment:t,version:n=1}=e,r=e.to??(typeof t=="string"?"hex":"bytes"),o=rh(t);return o.set([n],0),r==="bytes"?o:ee(o)}function ih(e){const{commitments:t,version:n}=e,r=e.to,o=[];for(const a of t)o.push(sh({commitment:a,to:r,version:n}));return o}const Vs=6,sa=32,ts=4096,ia=sa*ts,Gs=ia*Vs-1-1*ts*Vs;class oh extends v{constructor({maxSize:t,size:n}){super("Blob size is too large.",{metaMessages:[`Max: ${t} bytes`,`Given: ${n} bytes`],name:"BlobSizeTooLargeError"})}}class ah extends v{constructor(){super("Blob data must not be empty.",{name:"EmptyBlobError"})}}function uh(e){const t=typeof e.data=="string"?Pe(e.data):e.data,n=X(t);if(!n)throw new ah;if(n>Gs)throw new oh({maxSize:Gs,size:n});const r=[];let o=!0,a=0;for(;o;){const u=Yr(new Uint8Array(ia));let c=0;for(;c<ts;){const d=t.slice(a,a+(sa-1));if(u.pushByte(0),u.pushBytes(d),d.length<31){u.pushByte(128),o=!1;break}c++,a+=31}r.push(u)}return r.map(u=>ee(u.bytes))}function ch(e){const{data:t,kzg:n,to:r}=e,o=e.blobs??uh({data:t}),a=e.commitments??na({blobs:o,kzg:n,to:r}),u=e.proofs??ra({blobs:o,commitments:a,kzg:n,to:r}),c=[];for(let d=0;d<o.length;d++)c.push({blob:o[d],commitment:a[d],proof:u[d]});return c}function dh(e){if(e.type)return e.type;if(typeof e.authorizationList<"u")return"eip7702";if(typeof e.blobs<"u"||typeof e.blobVersionedHashes<"u"||typeof e.maxFeePerBlobGas<"u"||typeof e.sidecars<"u")return"eip4844";if(typeof e.maxFeePerGas<"u"||typeof e.maxPriorityFeePerGas<"u")return"eip1559";if(typeof e.gasPrice<"u")return typeof e.accessList<"u"?"eip2930":"legacy";throw new mp({transaction:e})}function Bn(e,{docsPath:t,...n}){const r=(()=>{const o=Yo(e,n);return o instanceof Jr?e:o})();return new gp(r,{docsPath:t,...n})}async function Ye(e){const t=await e.request({method:"eth_chainId"},{dedupe:!0});return Ie(t)}async function oa(e,t){const{account:n=e.account,accessList:r,authorizationList:o,chain:a=e.chain,blobVersionedHashes:u,blobs:c,data:d,gas:p,gasPrice:f,maxFeePerBlobGas:m,maxFeePerGas:y,maxPriorityFeePerGas:b,nonce:x,nonceManager:T,to:A,type:S,value:C,...I}=t,D=await(async()=>{if(!n||!T||typeof x<"u")return x;const _=J(n),K=a?a.id:await O(e,Ye,"getChainId")({});return await T.consume({address:_.address,chainId:K,client:e})})();pt(t);const B=a?.formatters?.transactionRequest?.format,L=(B||en)({...Un(I,{format:B}),account:n?J(n):void 0,accessList:r,authorizationList:o,blobs:c,blobVersionedHashes:u,data:d,gas:p,gasPrice:f,maxFeePerBlobGas:m,maxFeePerGas:y,maxPriorityFeePerGas:b,nonce:D,to:A,type:S,value:C},"fillTransaction");try{const _=await e.request({method:"eth_fillTransaction",params:[L]}),R=(a?.formatters?.transaction?.format||es)(_.tx);delete R.blockHash,delete R.blockNumber,delete R.r,delete R.s,delete R.transactionIndex,delete R.v,delete R.yParity,R.data=R.input,R.gas&&(R.gas=t.gas??R.gas),R.gasPrice&&(R.gasPrice=t.gasPrice??R.gasPrice),R.maxFeePerBlobGas&&(R.maxFeePerBlobGas=t.maxFeePerBlobGas??R.maxFeePerBlobGas),R.maxFeePerGas&&(R.maxFeePerGas=t.maxFeePerGas??R.maxFeePerGas),R.maxPriorityFeePerGas&&(R.maxPriorityFeePerGas=t.maxPriorityFeePerGas??R.maxPriorityFeePerGas),R.nonce&&(R.nonce=t.nonce??R.nonce);const H=await(async()=>{if(typeof a?.fees?.baseFeeMultiplier=="function"){const ge=await O(e,dt,"getBlock")({});return a.fees.baseFeeMultiplier({block:ge,client:e,request:t})}return a?.fees?.baseFeeMultiplier??1.2})();if(H<1)throw new Zo;const me=10**(H.toString().split(".")[1]?.length??0),_e=ge=>ge*BigInt(Math.ceil(H*me))/BigInt(me);return R.maxFeePerGas&&!t.maxFeePerGas&&(R.maxFeePerGas=_e(R.maxFeePerGas)),R.gasPrice&&!t.gasPrice&&(R.gasPrice=_e(R.gasPrice)),{raw:_.raw,transaction:{from:L.from,...R}}}catch(_){throw Bn(_,{...t,chain:e.chain})}}const ns=["blobVersionedHashes","chainId","fees","gas","nonce","type"],js=new Map,Wn=new ft(128);async function $n(e,t){const{account:n=e.account,chain:r,nonceManager:o,parameters:a=ns}=t;let u;async function c(){return u||(r?r.id:typeof t.chainId<"u"?t.chainId:(u=await O(e,Ye,"getChainId")({}),u))}const d=n&&J(n);let p=t.nonce;if(a.includes("nonce")&&typeof p>"u"&&d&&o){const I=await c();p=await o.consume({address:d.address,chainId:I,client:e})}const m=Wn.get(e.uid)!==!1&&["fees","gas"].some(I=>t.parameters?.includes(I))?await O(e,oa,"fillTransaction")({...t,nonce:p}).then(I=>{const{chainId:D,from:B,gas:W,gasPrice:L,nonce:_,maxFeePerBlobGas:K,maxFeePerGas:R,maxPriorityFeePerGas:H,type:Z}=I.transaction;return Wn.set(e.uid,!0),{...t,...D?{chainId:D}:{},...B?{from:B}:{},...W?{gas:W}:{},...L?{gasPrice:L}:{},..._?{nonce:_}:{},...K?{maxFeePerBlobGas:K}:{},...R?{maxFeePerGas:R}:{},...H?{maxPriorityFeePerGas:H}:{},...Z?{type:Z}:{}}}).catch(I=>(I.walk(W=>{const L=W;return L.name==="MethodNotFoundRpcError"||L.name==="MethodNotSupportedRpcError"})&&Wn.set(e.uid,!1),t)):t,{blobs:y,gas:b,kzg:x,type:T}=m;p??=m.nonce;const A={...m,...d?{from:d?.address}:{},...p?{nonce:p}:{}};let S;async function C(){return S||(S=await O(e,dt,"getBlock")({blockTag:"latest"}),S)}if(a.includes("nonce")&&typeof p>"u"&&d&&!o&&(A.nonce=await O(e,ta,"getTransactionCount")({address:d.address,blockTag:"pending"})),(a.includes("blobVersionedHashes")||a.includes("sidecars"))&&y&&x){const I=na({blobs:y,kzg:x});if(a.includes("blobVersionedHashes")){const D=ih({commitments:I,to:"hex"});A.blobVersionedHashes=D}if(a.includes("sidecars")){const D=ra({blobs:y,commitments:I,kzg:x}),B=ch({blobs:y,commitments:I,proofs:D,to:"hex"});A.sidecars=B}}if(a.includes("chainId")&&(A.chainId=await c()),(a.includes("fees")||a.includes("type"))&&typeof T>"u")try{A.type=dh(A)}catch{let I=js.get(e.uid);typeof I>"u"&&(I=typeof(await C())?.baseFeePerGas=="bigint",js.set(e.uid,I)),A.type=I?"eip1559":"legacy"}if(a.includes("fees"))if(A.type!=="legacy"&&A.type!=="eip2930"){if(typeof A.maxFeePerGas>"u"||typeof A.maxPriorityFeePerGas>"u"){const I=await C(),{maxFeePerGas:D,maxPriorityFeePerGas:B}=await Hs(e,{block:I,chain:r,request:A});if(typeof A.maxPriorityFeePerGas>"u"&&A.maxFeePerGas&&A.maxFeePerGas<B)throw new Gp({maxPriorityFeePerGas:B});A.maxPriorityFeePerGas=B,A.maxFeePerGas=D}}else{if(typeof A.maxFeePerGas<"u"||typeof A.maxPriorityFeePerGas<"u")throw new Qr;if(typeof A.gasPrice>"u"){const I=await C(),{gasPrice:D}=await Hs(e,{block:I,chain:r,request:A,type:"legacy"});A.gasPrice=D}}return a.includes("gas")&&typeof b>"u"&&(A.gas=await O(e,lh,"estimateGas")({...A,account:d,prepare:d?.type==="local"?[]:["blobVersionedHashes"]})),pt(A),delete A.parameters,A}async function lh(e,t){const{account:n=e.account,prepare:r=!0}=t,o=n?J(n):void 0,a=(()=>{if(Array.isArray(r))return r;if(o?.type!=="local")return["blobVersionedHashes"]})();try{const{accessList:u,authorizationList:c,blobs:d,blobVersionedHashes:p,blockNumber:f,blockTag:m,data:y,gas:b,gasPrice:x,maxFeePerBlobGas:T,maxFeePerGas:A,maxPriorityFeePerGas:S,nonce:C,value:I,stateOverride:D,...B}=r?await $n(e,{...t,parameters:a}):t,L=(typeof f=="bigint"?$(f):void 0)||m,_=Hp(D),K=await(async()=>{if(B.to)return B.to;if(c&&c.length>0)return await Zr({authorization:c[0]}).catch(()=>{throw new v("`to` is required. Could not infer from `authorizationList`")})})();pt(t);const R=e.chain?.formatters?.transactionRequest?.format,Z=(R||en)({...Un(B,{format:R}),account:o,accessList:u,authorizationList:c,blobs:d,blobVersionedHashes:p,data:y,gas:b,gasPrice:x,maxFeePerBlobGas:T,maxFeePerGas:A,maxPriorityFeePerGas:S,nonce:C,to:K,value:I},"estimateGas");return BigInt(await e.request({method:"eth_estimateGas",params:_?[Z,L??e.experimental_blockTag??"latest",_]:L?[Z,L]:[Z]}))}catch(u){throw Np(u,{...t,account:o,chain:e.chain})}}function fh(e,t){if(!ie(e,{strict:!1}))throw new Oe({address:e});if(!ie(t,{strict:!1}))throw new Oe({address:t});return e.toLowerCase()===t.toLowerCase()}function ph(e,{args:t,eventName:n}={}){return{...e,blockHash:e.blockHash?e.blockHash:null,blockNumber:e.blockNumber?BigInt(e.blockNumber):null,logIndex:e.logIndex?Number(e.logIndex):null,transactionHash:e.transactionHash?e.transactionHash:null,transactionIndex:e.transactionIndex?Number(e.transactionIndex):null,...n?{args:t,eventName:n}:{}}}class hh extends v{constructor({chain:t,currentChainId:n}){super(`The current chain of the wallet (id: ${n}) does not match the target chain for the transaction (id: ${t.id} – ${t.name}).`,{metaMessages:[`Current Chain ID:  ${n}`,`Expected Chain ID: ${t.id} – ${t.name}`],name:"ChainMismatchError"})}}class yh extends v{constructor(){super(["No chain was provided to the request.","Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."].join(`
`),{name:"ChainNotFoundError"})}}const Xn="/docs/contract/encodeDeployData";function mh(e){const{abi:t,args:n,bytecode:r}=e;if(!n||n.length===0)return r;const o=t.find(u=>"type"in u&&u.type==="constructor");if(!o)throw new Hl({docsPath:Xn});if(!("inputs"in o))throw new Is({docsPath:Xn});if(!o.inputs||o.inputs.length===0)throw new Is({docsPath:Xn});const a=Do(o.inputs,n);return kn([r,a])}function aa(){let e=()=>{},t=()=>{};return{promise:new Promise((r,o)=>{e=r,t=o}),resolve:e,reject:t}}const Kn=new Map,Ws=new Map;let gh=0;function xn(e,t,n){const r=++gh,o=()=>Kn.get(e)||[],a=()=>{const f=o();Kn.set(e,f.filter(m=>m.id!==r))},u=()=>{const f=o();if(!f.some(y=>y.id===r))return;const m=Ws.get(e);if(f.length===1&&m){const y=m();y instanceof Promise&&y.catch(()=>{})}a()},c=o();if(Kn.set(e,[...c,{id:r,fns:t}]),c&&c.length>0)return u;const d={};for(const f in t)d[f]=((...m)=>{const y=o();if(y.length!==0)for(const b of y)b.fns[f]?.(...m)});const p=n(d);return typeof p=="function"&&Ws.set(e,p),u}async function vr(e){return new Promise(t=>setTimeout(t,e))}function ua(e,{emitOnBegin:t,initialWaitTime:n,interval:r}){let o=!0;const a=()=>o=!1;return(async()=>{let c;t&&(c=await e({unpoll:a}));const d=await n?.(c)??r;await vr(d);const p=async()=>{o&&(await e({unpoll:a}),await vr(r),p())};p()})(),a}const bh=new Map,wh=new Map;function xh(e){const t=(o,a)=>({clear:()=>a.delete(o),get:()=>a.get(o),set:u=>a.set(o,u)}),n=t(e,bh),r=t(e,wh);return{clear:()=>{n.clear(),r.clear()},promise:n,response:r}}async function Ah(e,{cacheKey:t,cacheTime:n=Number.POSITIVE_INFINITY}){const r=xh(t),o=r.response.get();if(o&&n>0&&Date.now()-o.created.getTime()<n)return o.data;let a=r.promise.get();a||(a=e(),r.promise.set(a));try{const u=await a;return r.response.set({created:new Date,data:u}),u}finally{r.promise.clear()}}const vh=e=>`blockNumber.${e}`;async function qh(e,{cacheTime:t=e.cacheTime}={}){const n=await Ah(()=>e.request({method:"eth_blockNumber"}),{cacheKey:vh(e.uid),cacheTime:t});return BigInt(n)}class ze extends v{constructor({docsPath:t}={}){super(["Could not find an Account to execute with this Action.","Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."].join(`
`),{docsPath:t,docsSlug:"account",name:"AccountNotFoundError"})}}class je extends v{constructor({docsPath:t,metaMessages:n,type:r}){super(`Account type "${r}" is not supported.`,{docsPath:t,metaMessages:n,name:"AccountTypeNotSupportedError"})}}function rs({chain:e,currentChainId:t}){if(!e)throw new yh;if(t!==e.id)throw new hh({chain:e,currentChainId:t})}async function ca(e,{serializedTransaction:t}){return e.request({method:"eth_sendRawTransaction",params:[t]},{retryCount:0})}const Yn=new ft(128);async function Dn(e,t){const{account:n=e.account,chain:r=e.chain,accessList:o,authorizationList:a,blobs:u,data:c,gas:d,gasPrice:p,maxFeePerBlobGas:f,maxFeePerGas:m,maxPriorityFeePerGas:y,nonce:b,type:x,value:T,...A}=t;if(typeof n>"u")throw new ze({docsPath:"/docs/actions/wallet/sendTransaction"});const S=n?J(n):null;try{pt(t);const C=await(async()=>{if(t.to)return t.to;if(t.to!==null&&a&&a.length>0)return await Zr({authorization:a[0]}).catch(()=>{throw new v("`to` is required. Could not infer from `authorizationList`.")})})();if(S?.type==="json-rpc"||S===null){let I;r!==null&&(I=await O(e,Ye,"getChainId")({}),rs({currentChainId:I,chain:r}));const D=e.chain?.formatters?.transactionRequest?.format,W=(D||en)({...Un(A,{format:D}),accessList:o,account:S,authorizationList:a,blobs:u,chainId:I,data:c,gas:d,gasPrice:p,maxFeePerBlobGas:f,maxFeePerGas:m,maxPriorityFeePerGas:y,nonce:b,to:C,type:x,value:T},"sendTransaction"),L=Yn.get(e.uid),_=L?"wallet_sendTransaction":"eth_sendTransaction";try{return await e.request({method:_,params:[W]},{retryCount:0})}catch(K){if(L===!1)throw K;const R=K;if(R.name==="InvalidInputRpcError"||R.name==="InvalidParamsRpcError"||R.name==="MethodNotFoundRpcError"||R.name==="MethodNotSupportedRpcError")return await e.request({method:"wallet_sendTransaction",params:[W]},{retryCount:0}).then(H=>(Yn.set(e.uid,!0),H)).catch(H=>{const Z=H;throw Z.name==="MethodNotFoundRpcError"||Z.name==="MethodNotSupportedRpcError"?(Yn.set(e.uid,!1),R):Z});throw R}}if(S?.type==="local"){const I=await O(e,$n,"prepareTransactionRequest")({account:S,accessList:o,authorizationList:a,blobs:u,chain:r,data:c,gas:d,gasPrice:p,maxFeePerBlobGas:f,maxFeePerGas:m,maxPriorityFeePerGas:y,nonce:b,nonceManager:S.nonceManager,parameters:[...ns,"sidecars"],type:x,value:T,...A,to:C}),D=r?.serializers?.transaction,B=await S.signTransaction(I,{serializer:D});return await O(e,ca,"sendRawTransaction")({serializedTransaction:B})}throw S?.type==="smart"?new je({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"}):new je({docsPath:"/docs/actions/wallet/sendTransaction",type:S?.type})}catch(C){throw C instanceof je?C:Bn(C,{...t,account:S,chain:t.chain||void 0})}}async function Xt(e,t){return Xt.internal(e,Dn,"sendTransaction",t)}(function(e){async function t(n,r,o,a){const{abi:u,account:c=n.account,address:d,args:p,dataSuffix:f,functionName:m,...y}=a;if(typeof c>"u")throw new ze({docsPath:"/docs/contract/writeContract"});const b=c?J(c):null,x=Oo({abi:u,args:p,functionName:m});try{return await O(n,r,o)({data:`${x}${f?f.replace("0x",""):""}`,to:d,account:b,...y})}catch(T){throw Cp(T,{abi:u,address:d,args:p,docsPath:"/docs/contract/writeContract",functionName:m,sender:b?.address})}}e.internal=t})(Xt||(Xt={}));class Th extends v{constructor(t){super(`Call bundle failed with status: ${t.statusCode}`,{name:"BundleFailedError"}),Object.defineProperty(this,"result",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.result=t}}function An(e,{delay:t=100,retryCount:n=2,shouldRetry:r=()=>!0}={}){return new Promise((o,a)=>{const u=async({count:c=0}={})=>{const d=async({error:p})=>{const f=typeof t=="function"?t({count:c,error:p}):t;f&&await vr(f),u({count:c+1})};try{const p=await e();o(p)}catch(p){if(c<n&&await r({count:c,error:p}))return d({error:p});a(p)}};u()})}const da={"0x0":"reverted","0x1":"success"};function la(e,t){const n={...e,blockNumber:e.blockNumber?BigInt(e.blockNumber):null,contractAddress:e.contractAddress?e.contractAddress:null,cumulativeGasUsed:e.cumulativeGasUsed?BigInt(e.cumulativeGasUsed):null,effectiveGasPrice:e.effectiveGasPrice?BigInt(e.effectiveGasPrice):null,gasUsed:e.gasUsed?BigInt(e.gasUsed):null,logs:e.logs?e.logs.map(r=>ph(r)):null,to:e.to?e.to:null,transactionIndex:e.transactionIndex?Ie(e.transactionIndex):null,status:e.status?da[e.status]:null,type:e.type?Qo[e.type]||e.type:null};return e.blobGasPrice&&(n.blobGasPrice=BigInt(e.blobGasPrice)),e.blobGasUsed&&(n.blobGasUsed=BigInt(e.blobGasUsed)),n}const fa="0x5792579257925792579257925792579257925792579257925792579257925792",pa=$(0,{size:32});async function ha(e,t){const{account:n=e.account,capabilities:r,chain:o=e.chain,experimental_fallback:a,experimental_fallbackDelay:u=32,forceAtomic:c=!1,id:d,version:p="2.0.0"}=t,f=n?J(n):null,m=t.calls.map(y=>{const b=y,x=b.abi?Oo({abi:b.abi,functionName:b.functionName,args:b.args}):b.data;return{data:b.dataSuffix&&x?Ne([x,b.dataSuffix]):x,to:b.to,value:b.value?$(b.value):void 0}});try{const y=await e.request({method:"wallet_sendCalls",params:[{atomicRequired:c,calls:m,capabilities:r,chainId:$(o.id),from:f?.address,id:d,version:p}]},{retryCount:0});return typeof y=="string"?{id:y}:y}catch(y){const b=y;if(a&&(b.name==="MethodNotFoundRpcError"||b.name==="MethodNotSupportedRpcError"||b.name==="UnknownRpcError"||b.details.toLowerCase().includes("does not exist / is not available")||b.details.toLowerCase().includes("missing or invalid. request()")||b.details.toLowerCase().includes("did not match any variant of untagged enum")||b.details.toLowerCase().includes("account upgraded to unsupported contract")||b.details.toLowerCase().includes("eip-7702 not supported")||b.details.toLowerCase().includes("unsupported wc_ method")||b.details.toLowerCase().includes("feature toggled misconfigured")||b.details.toLowerCase().includes("jsonrpcengine: response has no error or result for request"))){if(r&&Object.values(r).some(C=>!C.optional)){const C="non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.";throw new ut(new v(C,{details:C}))}if(c&&m.length>1){const S="`forceAtomic` is not supported on fallback to `eth_sendTransaction`.";throw new ct(new v(S,{details:S}))}const x=[];for(const S of m){const C=Dn(e,{account:f,chain:o,data:S.data,to:S.to,value:S.value?Ce(S.value):void 0});x.push(C),u>0&&await new Promise(I=>setTimeout(I,u))}const T=await Promise.allSettled(x);if(T.every(S=>S.status==="rejected"))throw T[0].reason;const A=T.map(S=>S.status==="fulfilled"?S.value:pa);return{id:Ne([...A,$(o.id,{size:32}),fa])}}throw Bn(y,{...t,account:f,chain:t.chain})}}async function ya(e,t){async function n(f){if(f.endsWith(fa.slice(2))){const y=Cn(lr(f,-64,-32)),b=lr(f,0,-64).slice(2).match(/.{1,64}/g),x=await Promise.all(b.map(A=>pa.slice(2)!==A?e.request({method:"eth_getTransactionReceipt",params:[`0x${A}`]},{dedupe:!0}):void 0)),T=x.some(A=>A===null)?100:x.every(A=>A?.status==="0x1")?200:x.every(A=>A?.status==="0x0")?500:600;return{atomic:!1,chainId:Ie(y),receipts:x.filter(Boolean),status:T,version:"2.0.0"}}return e.request({method:"wallet_getCallsStatus",params:[f]})}const{atomic:r=!1,chainId:o,receipts:a,version:u="2.0.0",...c}=await n(t.id),[d,p]=(()=>{const f=c.status;return f>=100&&f<200?["pending",f]:f>=200&&f<300?["success",f]:f>=300&&f<700?["failure",f]:f==="CONFIRMED"?["success",200]:f==="PENDING"?["pending",100]:[void 0,f]})();return{...c,atomic:r,chainId:o?Ie(o):void 0,receipts:a?.map(f=>({...f,blockNumber:Ce(f.blockNumber),gasUsed:Ce(f.gasUsed),status:da[f.status]}))??[],statusCode:p,status:d,version:u}}async function ma(e,t){const{id:n,pollingInterval:r=e.pollingInterval,status:o=({statusCode:T})=>T===200||T>=300,retryCount:a=4,retryDelay:u=({count:T})=>~~(1<<T)*200,timeout:c=6e4,throwOnFailure:d=!1}=t,p=Ae(["waitForCallsStatus",e.uid,n]),{promise:f,resolve:m,reject:y}=aa();let b;const x=xn(p,{resolve:m,reject:y},T=>{const A=ua(async()=>{const S=C=>{clearTimeout(b),A(),C(),x()};try{const C=await An(async()=>{const I=await O(e,ya,"getCallsStatus")({id:n});if(d&&I.status==="failure")throw new Th(I);return I},{retryCount:a,delay:u});if(!o(C))return;S(()=>T.resolve(C))}catch(C){S(()=>T.reject(C))}},{interval:r,emitOnBegin:!0});return A});return b=c?setTimeout(()=>{x(),clearTimeout(b),y(new Eh({id:n}))},c):void 0,await f}class Eh extends v{constructor({id:t}){super(`Timed out while waiting for call bundle with id "${t}" to be confirmed.`,{name:"WaitForCallsStatusTimeoutError"})}}const qr=256;let sn=qr,on;function ga(e=11){if(!on||sn+e>qr*2){on="",sn=0;for(let t=0;t<qr;t++)on+=(256+Math.random()*256|0).toString(16).substring(1)}return on.substring(sn,sn+++e)}function Sh(e){const{batch:t,chain:n,ccipRead:r,key:o="base",name:a="Base Client",type:u="base"}=e,c=e.experimental_blockTag??(typeof n?.experimental_preconfirmationTime=="number"?"pending":void 0),d=n?.blockTime??12e3,p=Math.min(Math.max(Math.floor(d/2),500),4e3),f=e.pollingInterval??p,m=e.cacheTime??f,y=e.account?J(e.account):void 0,{config:b,request:x,value:T}=e.transport({account:y,chain:n,pollingInterval:f}),A={...b,...T},S={account:y,batch:t,cacheTime:m,ccipRead:r,chain:n,key:o,name:a,pollingInterval:f,request:x,transport:A,type:u,uid:ga(),...c?{experimental_blockTag:c}:{}};function C(I){return D=>{const B=D(I);for(const L in S)delete B[L];const W={...I,...B};return Object.assign(W,{extend:C(W)})}}return Object.assign(S,{extend:C(S)})}const an=new ft(8192);function Ch(e,{enabled:t=!0,id:n}){if(!t||!n)return e();if(an.get(n))return an.get(n);const r=e().finally(()=>an.delete(n));return an.set(n,r),r}function Ih(e,t={}){return async(n,r={})=>{const{dedupe:o=!1,methods:a,retryDelay:u=150,retryCount:c=3,uid:d}={...t,...r},{method:p}=n;if(a?.exclude?.includes(p))throw new Ve(new Error("method not supported"),{method:p});if(a?.include&&!a.include.includes(p))throw new Ve(new Error("method not supported"),{method:p});const f=o?In(`${d}.${Ae(n)}`):void 0;return Ch(()=>An(async()=>{try{return await e(n)}catch(m){const y=m;switch(y.code){case kt.code:throw new kt(y);case Rt.code:throw new Rt(y);case Ut.code:throw new Ut(y,{method:n.method});case Bt.code:throw new Bt(y);case Ke.code:throw new Ke(y);case ot.code:throw new ot(y);case $t.code:throw new $t(y);case Dt.code:throw new Dt(y);case Mt.code:throw new Mt(y);case Ve.code:throw new Ve(y,{method:n.method});case at.code:throw new at(y);case Ft.code:throw new Ft(y);case Qe.code:throw new Qe(y);case Ot.code:throw new Ot(y);case Nt.code:throw new Nt(y);case Lt.code:throw new Lt(y);case zt.code:throw new zt(y);case _t.code:throw new _t(y);case ut.code:throw new ut(y);case Ht.code:throw new Ht(y);case Vt.code:throw new Vt(y);case Gt.code:throw new Gt(y);case jt.code:throw new jt(y);case Wt.code:throw new Wt(y);case ct.code:throw new ct(y);case 5e3:throw new Qe(y);default:throw m instanceof v?m:new Ep(y)}}},{delay:({count:m,error:y})=>{if(y&&y instanceof jo){const b=y?.headers?.get("Retry-After");if(b?.match(/\d/))return Number.parseInt(b,10)*1e3}return~~(1<<m)*u},retryCount:c,shouldRetry:({error:m})=>Ph(m)}),{enabled:o,id:f})}}function Ph(e){return"code"in e&&typeof e.code=="number"?e.code===-1||e.code===at.code||e.code===Ke.code:e instanceof jo&&e.status?e.status===403||e.status===408||e.status===413||e.status===429||e.status===500||e.status===502||e.status===503||e.status===504:!0}function kh(e){return{formatters:void 0,fees:void 0,serializers:void 0,...e}}class Rh extends v{constructor({domain:t}){super(`Invalid domain "${Ae(t)}".`,{metaMessages:["Must be a valid EIP-712 domain."]})}}class Uh extends v{constructor({primaryType:t,types:n}){super(`Invalid primary type \`${t}\` must be one of \`${JSON.stringify(Object.keys(n))}\`.`,{docsPath:"/api/glossary/Errors#typeddatainvalidprimarytypeerror",metaMessages:["Check that the primary type is a key in `types`."]})}}class Bh extends v{constructor({type:t}){super(`Struct type "${t}" is invalid.`,{metaMessages:["Struct type must not be a Solidity type."],name:"InvalidStructTypeError"})}}function $h(e){const{domain:t,message:n,primaryType:r,types:o}=e,a=(d,p)=>{const f={...p};for(const m of d){const{name:y,type:b}=m;b==="address"&&(f[y]=f[y].toLowerCase())}return f},u=o.EIP712Domain?t?a(o.EIP712Domain,t):{}:{},c=(()=>{if(r!=="EIP712Domain")return a(o[r],n)})();return Ae({domain:u,message:c,primaryType:r,types:o})}function Dh(e){const{domain:t,message:n,primaryType:r,types:o}=e,a=(u,c)=>{for(const d of u){const{name:p,type:f}=d,m=c[p],y=f.match($o);if(y&&(typeof m=="number"||typeof m=="bigint")){const[T,A,S]=y;$(m,{signed:A==="int",size:Number.parseInt(S,10)/8})}if(f==="address"&&typeof m=="string"&&!ie(m))throw new Oe({address:m});const b=f.match(Of);if(b){const[T,A]=b;if(A&&X(m)!==Number.parseInt(A,10))throw new Kl({expectedSize:Number.parseInt(A,10),givenSize:X(m)})}const x=o[f];x&&(Fh(f),a(x,m))}};if(o.EIP712Domain&&t){if(typeof t!="object")throw new Rh({domain:t});a(o.EIP712Domain,t)}if(r!=="EIP712Domain")if(o[r])a(o[r],n);else throw new Uh({primaryType:r,types:o})}function Mh({domain:e}){return[typeof e?.name=="string"&&{name:"name",type:"string"},e?.version&&{name:"version",type:"string"},(typeof e?.chainId=="number"||typeof e?.chainId=="bigint")&&{name:"chainId",type:"uint256"},e?.verifyingContract&&{name:"verifyingContract",type:"address"},e?.salt&&{name:"salt",type:"bytes32"}].filter(Boolean)}function Fh(e){if(e==="address"||e==="bool"||e==="string"||e.startsWith("bytes")||e.startsWith("uint")||e.startsWith("int"))throw new Bh({type:e})}async function Oh(e,{blockHash:t,blockNumber:n,blockTag:r,hash:o,index:a,sender:u,nonce:c}){const d=r||"latest",p=n!==void 0?$(n):void 0;let f=null;if(o?f=await e.request({method:"eth_getTransactionByHash",params:[o]},{dedupe:!0}):t?f=await e.request({method:"eth_getTransactionByBlockHashAndIndex",params:[t,$(a)]},{dedupe:!0}):typeof a=="number"?f=await e.request({method:"eth_getTransactionByBlockNumberAndIndex",params:[p||d,$(a)]},{dedupe:!!p}):u&&typeof c=="number"&&(f=await e.request({method:"eth_getTransactionBySenderAndNonce",params:[u,$(c)]},{dedupe:!0})),!f)throw new _o({blockHash:t,blockNumber:n,blockTag:d,hash:o,index:a});return(e.chain?.formatters?.transaction?.format||es)(f,"getTransaction")}async function Zn(e,{hash:t}){const n=await e.request({method:"eth_getTransactionReceipt",params:[t]},{dedupe:!0});if(!n)throw new Ho({hash:t});return(e.chain?.formatters?.transactionReceipt?.format||la)(n,"getTransactionReceipt")}function Nh(e,{emitOnBegin:t=!1,emitMissed:n=!1,onBlockNumber:r,onError:o,poll:a,pollingInterval:u=e.pollingInterval}){const c=typeof a<"u"?a:!(e.transport.type==="webSocket"||e.transport.type==="ipc"||e.transport.type==="fallback"&&(e.transport.transports[0].config.type==="webSocket"||e.transport.transports[0].config.type==="ipc"));let d;return c?(()=>{const m=Ae(["watchBlockNumber",e.uid,t,n,u]);return xn(m,{onBlockNumber:r,onError:o},y=>ua(async()=>{try{const b=await O(e,qh,"getBlockNumber")({cacheTime:0});if(d!==void 0){if(b===d)return;if(b-d>1&&n)for(let x=d+1n;x<b;x++)y.onBlockNumber(x,d),d=x}(d===void 0||b>d)&&(y.onBlockNumber(b,d),d=b)}catch(b){y.onError?.(b)}},{emitOnBegin:t,interval:u}))})():(()=>{const m=Ae(["watchBlockNumber",e.uid,t,n]);return xn(m,{onBlockNumber:r,onError:o},y=>{let b=!0,x=()=>b=!1;return(async()=>{try{const T=(()=>{if(e.transport.type==="fallback"){const S=e.transport.transports.find(C=>C.config.type==="webSocket"||C.config.type==="ipc");return S?S.value:e.transport}return e.transport})(),{unsubscribe:A}=await T.subscribe({params:["newHeads"],onData(S){if(!b)return;const C=Ce(S.result?.number);y.onBlockNumber(C,d),d=C},onError(S){y.onError?.(S)}});x=A,b||x()}catch(T){o?.(T)}})(),()=>x()})})()}async function Lh(e,t){const{checkReplacement:n=!0,confirmations:r=1,hash:o,onReplaced:a,retryCount:u=6,retryDelay:c=({count:B})=>~~(1<<B)*200,timeout:d=18e4}=t,p=Ae(["waitForTransactionReceipt",e.uid,o]),f=t.pollingInterval?t.pollingInterval:e.chain?.experimental_preconfirmationTime?e.chain.experimental_preconfirmationTime:e.pollingInterval;let m,y,b,x=!1,T,A;const{promise:S,resolve:C,reject:I}=aa(),D=d?setTimeout(()=>{A?.(),T?.(),I(new bp({hash:o}))},d):void 0;return T=xn(p,{onReplaced:a,resolve:C,reject:I},async B=>{if(b=await O(e,Zn,"getTransactionReceipt")({hash:o}).catch(()=>{}),b&&r<=1){clearTimeout(D),B.resolve(b),T?.();return}A=O(e,Nh,"watchBlockNumber")({emitMissed:!0,emitOnBegin:!0,poll:!0,pollingInterval:f,async onBlockNumber(W){const L=K=>{clearTimeout(D),A?.(),K(),T?.()};let _=W;if(!x)try{if(b){if(r>1&&(!b.blockNumber||_-b.blockNumber+1n<r))return;L(()=>B.resolve(b));return}if(n&&!m&&(x=!0,await An(async()=>{m=await O(e,Oh,"getTransaction")({hash:o}),m.blockNumber&&(_=m.blockNumber)},{delay:c,retryCount:u}),x=!1),b=await O(e,Zn,"getTransactionReceipt")({hash:o}),r>1&&(!b.blockNumber||_-b.blockNumber+1n<r))return;L(()=>B.resolve(b))}catch(K){if(K instanceof _o||K instanceof Ho){if(!m){x=!1;return}try{y=m,x=!0;const R=await An(()=>O(e,dt,"getBlock")({blockNumber:_,includeTransactions:!0}),{delay:c,retryCount:u,shouldRetry:({error:me})=>me instanceof Jo});x=!1;const H=R.transactions.find(({from:me,nonce:_e})=>me===y.from&&_e===y.nonce);if(!H||(b=await O(e,Zn,"getTransactionReceipt")({hash:H.hash}),r>1&&(!b.blockNumber||_-b.blockNumber+1n<r)))return;let Z="replaced";H.to===y.to&&H.value===y.value&&H.input===y.input?Z="repriced":H.from===H.to&&H.value===0n&&(Z="cancelled"),L(()=>{B.onReplaced?.({reason:Z,replacedTransaction:y,transaction:H,transactionReceipt:b}),B.resolve(b)})}catch(R){L(()=>B.reject(R))}}else L(()=>B.reject(K))}}})}),S}async function ba(e,{serializedTransaction:t,throwOnReceiptRevert:n,timeout:r}){const o=await e.request({method:"eth_sendRawTransactionSync",params:r?[t,$(r)]:[t]},{retryCount:0}),u=(e.chain?.formatters?.transactionReceipt?.format||la)(o);if(u.status==="reverted"&&n)throw new Vo({receipt:u});return u}async function zh(e,{chain:t}){const{id:n,name:r,nativeCurrency:o,rpcUrls:a,blockExplorers:u}=t;await e.request({method:"wallet_addEthereumChain",params:[{chainId:$(n),chainName:r,nativeCurrency:o,rpcUrls:a.default.http,blockExplorerUrls:u?Object.values(u).map(({url:c})=>c):void 0}]},{dedupe:!0,retryCount:0})}function _h(e,t){const{abi:n,args:r,bytecode:o,...a}=t,u=mh({abi:n,args:r,bytecode:o});return Dn(e,{...a,...a.authorizationList?{to:null}:{},data:u})}async function Hh(e){return e.account?.type==="local"?[e.account.address]:(await e.request({method:"eth_accounts"},{dedupe:!0})).map(n=>Qt(n))}async function Vh(e,t={}){const{account:n=e.account,chainId:r}=t,o=n?J(n):void 0,a=r?[o?.address,[$(r)]]:[o?.address],u=await e.request({method:"wallet_getCapabilities",params:a}),c={};for(const[d,p]of Object.entries(u)){c[Number(d)]={};for(let[f,m]of Object.entries(p))f==="addSubAccount"&&(f="unstable_addSubAccount"),c[Number(d)][f]=m}return typeof r=="number"?c[r]:c}async function Gh(e){return await e.request({method:"wallet_getPermissions"},{dedupe:!0})}async function wa(e,t){const{account:n=e.account,chainId:r,nonce:o}=t;if(!n)throw new ze({docsPath:"/docs/eip7702/prepareAuthorization"});const a=J(n),u=(()=>{if(t.executor)return t.executor==="self"?t.executor:J(t.executor)})(),c={address:t.contractAddress??t.address,chainId:r,nonce:o};return typeof c.chainId>"u"&&(c.chainId=e.chain?.id??await O(e,Ye,"getChainId")({})),typeof c.nonce>"u"&&(c.nonce=await O(e,ta,"getTransactionCount")({address:a.address,blockTag:"pending"}),(u==="self"||u?.address&&fh(u.address,a.address))&&(c.nonce+=1)),c}async function jh(e){return(await e.request({method:"eth_requestAccounts"},{dedupe:!0,retryCount:0})).map(n=>ko(n))}async function Wh(e,t){return e.request({method:"wallet_requestPermissions",params:[t]},{retryCount:0})}async function Xh(e,t){const{chain:n=e.chain}=t,r=t.timeout??Math.max((n?.blockTime??0)*3,5e3),o=await ha(e,t);return await ma(e,{...t,id:o.id,timeout:r})}const Jn=new ft(128);async function xa(e,t){const{account:n=e.account,chain:r=e.chain,accessList:o,authorizationList:a,blobs:u,data:c,gas:d,gasPrice:p,maxFeePerBlobGas:f,maxFeePerGas:m,maxPriorityFeePerGas:y,nonce:b,pollingInterval:x,throwOnReceiptRevert:T,type:A,value:S,...C}=t,I=t.timeout??Math.max((r?.blockTime??0)*3,5e3);if(typeof n>"u")throw new ze({docsPath:"/docs/actions/wallet/sendTransactionSync"});const D=n?J(n):null;try{pt(t);const B=await(async()=>{if(t.to)return t.to;if(t.to!==null&&a&&a.length>0)return await Zr({authorization:a[0]}).catch(()=>{throw new v("`to` is required. Could not infer from `authorizationList`.")})})();if(D?.type==="json-rpc"||D===null){let W;r!==null&&(W=await O(e,Ye,"getChainId")({}),rs({currentChainId:W,chain:r}));const L=e.chain?.formatters?.transactionRequest?.format,K=(L||en)({...Un(C,{format:L}),accessList:o,account:D,authorizationList:a,blobs:u,chainId:W,data:c,gas:d,gasPrice:p,maxFeePerBlobGas:f,maxFeePerGas:m,maxPriorityFeePerGas:y,nonce:b,to:B,type:A,value:S},"sendTransaction"),R=Jn.get(e.uid),H=R?"wallet_sendTransaction":"eth_sendTransaction",Z=await(async()=>{try{return await e.request({method:H,params:[K]},{retryCount:0})}catch(_e){if(R===!1)throw _e;const ge=_e;if(ge.name==="InvalidInputRpcError"||ge.name==="InvalidParamsRpcError"||ge.name==="MethodNotFoundRpcError"||ge.name==="MethodNotSupportedRpcError")return await e.request({method:"wallet_sendTransaction",params:[K]},{retryCount:0}).then(Mn=>(Jn.set(e.uid,!0),Mn)).catch(Mn=>{const Fn=Mn;throw Fn.name==="MethodNotFoundRpcError"||Fn.name==="MethodNotSupportedRpcError"?(Jn.set(e.uid,!1),ge):Fn});throw ge}})(),me=await O(e,Lh,"waitForTransactionReceipt")({checkReplacement:!1,hash:Z,pollingInterval:x,timeout:I});if(T&&me.status==="reverted")throw new Vo({receipt:me});return me}if(D?.type==="local"){const W=await O(e,$n,"prepareTransactionRequest")({account:D,accessList:o,authorizationList:a,blobs:u,chain:r,data:c,gas:d,gasPrice:p,maxFeePerBlobGas:f,maxFeePerGas:m,maxPriorityFeePerGas:y,nonce:b,nonceManager:D.nonceManager,parameters:[...ns,"sidecars"],type:A,value:S,...C,to:B}),L=r?.serializers?.transaction,_=await D.signTransaction(W,{serializer:L});return await O(e,ba,"sendRawTransactionSync")({serializedTransaction:_,throwOnReceiptRevert:T})}throw D?.type==="smart"?new je({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"}):new je({docsPath:"/docs/actions/wallet/sendTransactionSync",type:D?.type})}catch(B){throw B instanceof je?B:Bn(B,{...t,account:D,chain:t.chain||void 0})}}async function Kh(e,t){const{id:n}=t;await e.request({method:"wallet_showCallsStatus",params:[n]})}async function Yh(e,t){const{account:n=e.account}=t;if(!n)throw new ze({docsPath:"/docs/eip7702/signAuthorization"});const r=J(n);if(!r.signAuthorization)throw new je({docsPath:"/docs/eip7702/signAuthorization",metaMessages:["The `signAuthorization` Action does not support JSON-RPC Accounts."],type:r.type});const o=await wa(e,t);return r.signAuthorization(o)}async function Zh(e,{account:t=e.account,message:n}){if(!t)throw new ze({docsPath:"/docs/actions/wallet/signMessage"});const r=J(t);if(r.signMessage)return r.signMessage({message:n});const o=typeof n=="string"?In(n):n.raw instanceof Uint8Array?yn(n.raw):n.raw;return e.request({method:"personal_sign",params:[o,r.address]},{retryCount:0})}async function Jh(e,t){const{account:n=e.account,chain:r=e.chain,...o}=t;if(!n)throw new ze({docsPath:"/docs/actions/wallet/signTransaction"});const a=J(n);pt({account:a,...t});const u=await O(e,Ye,"getChainId")({});r!==null&&rs({currentChainId:u,chain:r});const d=(r?.formatters||e.chain?.formatters)?.transactionRequest?.format||en;return a.signTransaction?a.signTransaction({...o,chainId:u},{serializer:e.chain?.serializers?.transaction}):await e.request({method:"eth_signTransaction",params:[{...d({...o,account:a},"signTransaction"),chainId:$(u),from:a.address}]},{retryCount:0})}async function Qh(e,t){const{account:n=e.account,domain:r,message:o,primaryType:a}=t;if(!n)throw new ze({docsPath:"/docs/actions/wallet/signTypedData"});const u=J(n),c={EIP712Domain:Mh({domain:r}),...t.types};if(Dh({domain:r,message:o,primaryType:a,types:c}),u.signTypedData)return u.signTypedData({domain:r,message:o,primaryType:a,types:c});const d=$h({domain:r,message:o,primaryType:a,types:c});return e.request({method:"eth_signTypedData_v4",params:[u.address,d]},{retryCount:0})}async function ey(e,{id:t}){await e.request({method:"wallet_switchEthereumChain",params:[{chainId:$(t)}]},{retryCount:0})}async function ty(e,t){return await e.request({method:"wallet_watchAsset",params:t},{retryCount:0})}async function ny(e,t){return Xt.internal(e,xa,"sendTransactionSync",t)}function ry(e){return{addChain:t=>zh(e,t),deployContract:t=>_h(e,t),fillTransaction:t=>oa(e,t),getAddresses:()=>Hh(e),getCallsStatus:t=>ya(e,t),getCapabilities:t=>Vh(e,t),getChainId:()=>Ye(e),getPermissions:()=>Gh(e),prepareAuthorization:t=>wa(e,t),prepareTransactionRequest:t=>$n(e,t),requestAddresses:()=>jh(e),requestPermissions:t=>Wh(e,t),sendCalls:t=>ha(e,t),sendCallsSync:t=>Xh(e,t),sendRawTransaction:t=>ca(e,t),sendRawTransactionSync:t=>ba(e,t),sendTransaction:t=>Dn(e,t),sendTransactionSync:t=>xa(e,t),showCallsStatus:t=>Kh(e,t),signAuthorization:t=>Yh(e,t),signMessage:t=>Zh(e,t),signTransaction:t=>Jh(e,t),signTypedData:t=>Qh(e,t),switchChain:t=>ey(e,t),waitForCallsStatus:t=>ma(e,t),watchAsset:t=>ty(e,t),writeContract:t=>Xt(e,t),writeContractSync:t=>ny(e,t)}}function sy(e){const{key:t="wallet",name:n="Wallet Client",transport:r}=e;return Sh({...e,key:t,name:n,transport:r,type:"walletClient"}).extend(ry)}function iy({key:e,methods:t,name:n,request:r,retryCount:o=3,retryDelay:a=150,timeout:u,type:c},d){const p=ga();return{config:{key:e,methods:t,name:n,request:r,retryCount:o,retryDelay:a,timeout:u,type:c},request:Ih(r,{methods:t,retryCount:o,retryDelay:a,uid:p}),value:d}}function oy(e,t={}){const{key:n="custom",methods:r,name:o="Custom Provider",retryDelay:a}=t;return({retryCount:u})=>iy({key:n,methods:r,name:o,request:e.request.bind(e),retryCount:t.retryCount??u,retryDelay:a,type:"custom"})}const ay=kh({id:42161,name:"Arbitrum One",nativeCurrency:{name:"Ether",symbol:"ETH",decimals:18},blockTime:250,rpcUrls:{default:{http:["https://arb1.arbitrum.io/rpc"]}},blockExplorers:{default:{name:"Arbiscan",url:"https://arbiscan.io",apiUrl:"https://api.arbiscan.io/api"}},contracts:{multicall3:{address:"0xca11bde05977b3631167028862be2a173976ca11",blockCreated:7654707}}}),uy=[{name:"Lit.Trader",address:"0x24a747628494231347f4f6aead2ec14f50bcc8b7"},{name:"BasedOne",address:"0x1924b8561eef20e70ede628a296175d358be80e5"},{name:"Dexari",address:"0x7975cafdff839ed5047244ed3a0dd82a89866081"},{name:"Liquid",address:"0x6d4e7f472e6a491b98cbeed327417e310ae8ce48"},{name:"Sueprcexy",address:"0x0000000bfbf4c62c43c2e71ef0093f382bf7a7b4"},{name:"Superstack",address:"0xcdb943570bcb48a6f1d3228d0175598fea19e87b"},{name:"Bullpen",address:"0x4c8731897503f86a2643959cbaa1e075e84babb7"},{name:"Mass",address:"0xf944069b489f1ebff4c3c6a6014d58cbef7c7009"},{name:"Tread.fi",address:"0x999a4b5f268a8fbf33736feff360d462ad248dbf"},{name:"Dreamcash",address:"0x4950994884602d1b6c6d96e4fe30f58205c39395"}];function ss(e){return ko(e)}let Tr=null,dn=null;document.querySelector("#app").innerHTML=`
  <div>
    <h1>Hyperliquid Builder Fee Approve</h1>

    <!-- 지갑 연결 -->
    <button id="connectBtn" style="padding: 10px 20px; font-size: 16px;">
      지갑 연결하기
    </button>

    <!-- 상태/잔고 -->
    <div id="status" style="margin-top: 20px; white-space: pre-line;">대기 중...</div>
    <div id="balance" style="font-weight: bold; margin-top: 10px;"></div>

    <hr style="margin: 24px 0;" />

    <!-- [추가] Builder 선택/입력 UI -->
    <h2>Builder Fee 승인</h2>
    <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
      <!-- [추가] 셀렉트 박스: 목록에서 선택 -->
      <select id="builderSelect" style="min-width: 280px; padding: 8px;">
        <!-- 옵션은 스크립트에서 주입 -->
      </select>

      <!-- [변경] 주소 직접 입력 필드(선택 시 자동 채움/잠금) -->
      <input id="builderAddress" placeholder="Builder 주소 (0x...)" style="width: 420px; padding: 8px;" />

      <input id="builderFee" placeholder="최대 수수료 % (예: 0.05)" style="width: 200px; padding: 8px;" />
      <button id="approveBtn" style="padding: 8px 16px;">Builder Fee 승인</button>
    </div>
    <div id="approveResult" style="margin-top: 12px; color: #0b7;"></div>
  </div>
`;const cy=document.querySelector("#connectBtn"),gt=document.querySelector("#status"),dy=document.querySelector("#balance"),ly=document.querySelector("#approveBtn"),re=document.querySelector("#approveResult"),Kt=document.querySelector("#builderSelect"),et=document.querySelector("#builderAddress"),fy=document.querySelector("#builderFee");function py(e){const t=e.filter(r=>ie(r.address)).map(r=>({name:r.name,address:ss(r.address)})).reduce((r,o)=>(r.set(o.address,o),r),new Map),n=[];n.push('<option value="__manual__">직접 입력 (수동)</option>');for(const{name:r,address:o}of t.values())n.push(`<option value="${o}">${r} — ${o}</option>`);Kt.innerHTML=n.join(""),Kt.value="__manual__",et.value="",et.readOnly=!1}Kt.addEventListener("change",()=>{const e=Kt.value;e==="__manual__"?et.readOnly=!1:(et.value=e,et.readOnly=!0)});py(uy);cy.addEventListener("click",async()=>{try{if(typeof window.ethereum>"u"){alert("지갑이 설치되어 있지 않음");return}gt.innerText="지갑 연결 중...";const e=sy({chain:ay,transport:oy(window.ethereum)}),t=await e.requestAddresses(),n=ss(t[0]);if(!n){gt.innerText="지갑 주소를 가져오지 못함 (메타마스크 잠금 해제 확인)";return}Tr=e,dn=n;const r=new ei,o=new po({transport:r}),a=await o.allMids();gt.innerText+=`
잔고 조회 중...`;const c=(await o.clearinghouseState({user:n}))?.marginSummary?.accountValue||"0";dy.innerText=`USDC 잔고: $${c}`,gt.innerText=`지갑 연결 완료: ${n}`}catch(e){console.error(e),gt.innerText=`에러 발생: ${e instanceof Error?e.message:String(e)}`}});function hy({walletClient:e,address:t}){return{address:t,signMessage:n=>e.signMessage({account:t,...n}),signTypedData:n=>e.signTypedData({account:t,...n})}}ly.addEventListener("click",async()=>{try{if(re.style.color="#0b7",re.innerText="",!Tr||!dn){alert("먼저 지갑을 연결하세요.");return}const e=Kt.value,t=e!=="__manual__"?e:(et.value||"").trim();if(!ie(t)){re.style.color="#c00",re.innerText="올바른 0x 주소를 입력하거나 목록에서 선택하세요.";return}const n=ss(t),r=(fy.value||"").trim(),o=Number(r);if(!Number.isFinite(o)||o<=0){re.style.color="#c00",re.innerText="수수료는 0보다 큰 숫자(%)로 입력하세요. 예: 0.05";return}if(o>1){re.style.color="#c00",re.innerText="최대 수수료%는 1.00% 이하여야 합니다.";return}const a=`${o}%`,u=new ei,c=hy({walletClient:Tr,address:dn}),d=new yc({wallet:c,transport:u}),p=new po({transport:u});re.innerText="Builder Fee 승인 트랜잭션 서명/전송 중... (지갑 확인)";const f=await d.approveBuilderFee({builder:n,maxFeeRate:a});console.log("approveBuilderFee 결과:",f);const y=(await p.maxBuilderFee({user:dn,builder:n}))?.maxBuilderFee??"0";re.style.color="#0b7",re.innerText=`승인 완료. builder=${n}
최대 수수료(저장값): ${y}`}catch(e){console.error(e),re.style.color="#c00",re.innerText=`승인 에러: ${e instanceof Error?e.message:String(e)}`}});
